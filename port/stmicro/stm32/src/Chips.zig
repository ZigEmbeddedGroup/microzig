//AUTOMATICALLY GENERATED FILE!
//For modifications, consider editing the generation script in generate.zig

const std = @import("std");
const microzig = @import("microzig/build-internals");

const Self = @This();

STM32C011D6: *microzig.Target,
STM32C011F4: *microzig.Target,
STM32C011F6: *microzig.Target,
STM32C011J4: *microzig.Target,
STM32C011J6: *microzig.Target,
STM32C031C4: *microzig.Target,
STM32C031C6: *microzig.Target,
STM32C031F4: *microzig.Target,
STM32C031F6: *microzig.Target,
STM32C031G4: *microzig.Target,
STM32C031G6: *microzig.Target,
STM32C031K4: *microzig.Target,
STM32C031K6: *microzig.Target,
STM32F030C6: *microzig.Target,
STM32F030C8: *microzig.Target,
STM32F030CC: *microzig.Target,
STM32F030F4: *microzig.Target,
STM32F030K6: *microzig.Target,
STM32F030R8: *microzig.Target,
STM32F030RC: *microzig.Target,
STM32F031C4: *microzig.Target,
STM32F031C6: *microzig.Target,
STM32F031E6: *microzig.Target,
STM32F031F4: *microzig.Target,
STM32F031F6: *microzig.Target,
STM32F031G4: *microzig.Target,
STM32F031G6: *microzig.Target,
STM32F031K4: *microzig.Target,
STM32F031K6: *microzig.Target,
STM32F038C6: *microzig.Target,
STM32F038E6: *microzig.Target,
STM32F038F6: *microzig.Target,
STM32F038G6: *microzig.Target,
STM32F038K6: *microzig.Target,
STM32F042C4: *microzig.Target,
STM32F042C6: *microzig.Target,
STM32F042F4: *microzig.Target,
STM32F042F6: *microzig.Target,
STM32F042G4: *microzig.Target,
STM32F042G6: *microzig.Target,
STM32F042K4: *microzig.Target,
STM32F042K6: *microzig.Target,
STM32F042T6: *microzig.Target,
STM32F048C6: *microzig.Target,
STM32F048G6: *microzig.Target,
STM32F048T6: *microzig.Target,
STM32F051C4: *microzig.Target,
STM32F051C6: *microzig.Target,
STM32F051C8: *microzig.Target,
STM32F051K4: *microzig.Target,
STM32F051K6: *microzig.Target,
STM32F051K8: *microzig.Target,
STM32F051R4: *microzig.Target,
STM32F051R6: *microzig.Target,
STM32F051R8: *microzig.Target,
STM32F051T8: *microzig.Target,
STM32F058C8: *microzig.Target,
STM32F058R8: *microzig.Target,
STM32F058T8: *microzig.Target,
STM32F070C6: *microzig.Target,
STM32F070CB: *microzig.Target,
STM32F070F6: *microzig.Target,
STM32F070RB: *microzig.Target,
STM32F071C8: *microzig.Target,
STM32F071CB: *microzig.Target,
STM32F071RB: *microzig.Target,
STM32F071V8: *microzig.Target,
STM32F071VB: *microzig.Target,
STM32F072C8: *microzig.Target,
STM32F072CB: *microzig.Target,
STM32F072R8: *microzig.Target,
STM32F072RB: *microzig.Target,
STM32F072V8: *microzig.Target,
STM32F072VB: *microzig.Target,
STM32F078CB: *microzig.Target,
STM32F078RB: *microzig.Target,
STM32F078VB: *microzig.Target,
STM32F091CB: *microzig.Target,
STM32F091CC: *microzig.Target,
STM32F091RB: *microzig.Target,
STM32F091RC: *microzig.Target,
STM32F091VB: *microzig.Target,
STM32F091VC: *microzig.Target,
STM32F098CC: *microzig.Target,
STM32F098RC: *microzig.Target,
STM32F098VC: *microzig.Target,
STM32F100C4: *microzig.Target,
STM32F100C6: *microzig.Target,
STM32F100C8: *microzig.Target,
STM32F100CB: *microzig.Target,
STM32F100R4: *microzig.Target,
STM32F100R6: *microzig.Target,
STM32F100R8: *microzig.Target,
STM32F100RB: *microzig.Target,
STM32F100RC: *microzig.Target,
STM32F100RD: *microzig.Target,
STM32F100RE: *microzig.Target,
STM32F100V8: *microzig.Target,
STM32F100VB: *microzig.Target,
STM32F100VC: *microzig.Target,
STM32F100VD: *microzig.Target,
STM32F100VE: *microzig.Target,
STM32F100ZC: *microzig.Target,
STM32F100ZD: *microzig.Target,
STM32F100ZE: *microzig.Target,
STM32F101C4: *microzig.Target,
STM32F101C6: *microzig.Target,
STM32F101C8: *microzig.Target,
STM32F101CB: *microzig.Target,
STM32F101R4: *microzig.Target,
STM32F101R6: *microzig.Target,
STM32F101R8: *microzig.Target,
STM32F101RB: *microzig.Target,
STM32F101RC: *microzig.Target,
STM32F101RD: *microzig.Target,
STM32F101RE: *microzig.Target,
STM32F101RF: *microzig.Target,
STM32F101RG: *microzig.Target,
STM32F101T4: *microzig.Target,
STM32F101T6: *microzig.Target,
STM32F101T8: *microzig.Target,
STM32F101TB: *microzig.Target,
STM32F101V8: *microzig.Target,
STM32F101VB: *microzig.Target,
STM32F101VC: *microzig.Target,
STM32F101VD: *microzig.Target,
STM32F101VE: *microzig.Target,
STM32F101VF: *microzig.Target,
STM32F101VG: *microzig.Target,
STM32F101ZC: *microzig.Target,
STM32F101ZD: *microzig.Target,
STM32F101ZE: *microzig.Target,
STM32F101ZF: *microzig.Target,
STM32F101ZG: *microzig.Target,
STM32F102C4: *microzig.Target,
STM32F102C6: *microzig.Target,
STM32F102C8: *microzig.Target,
STM32F102CB: *microzig.Target,
STM32F102R4: *microzig.Target,
STM32F102R6: *microzig.Target,
STM32F102R8: *microzig.Target,
STM32F102RB: *microzig.Target,
STM32F103C4: *microzig.Target,
STM32F103C6: *microzig.Target,
STM32F103C8: *microzig.Target,
STM32F103CB: *microzig.Target,
STM32F103R4: *microzig.Target,
STM32F103R6: *microzig.Target,
STM32F103R8: *microzig.Target,
STM32F103RB: *microzig.Target,
STM32F103RC: *microzig.Target,
STM32F103RD: *microzig.Target,
STM32F103RE: *microzig.Target,
STM32F103RF: *microzig.Target,
STM32F103RG: *microzig.Target,
STM32F103T4: *microzig.Target,
STM32F103T6: *microzig.Target,
STM32F103T8: *microzig.Target,
STM32F103TB: *microzig.Target,
STM32F103V8: *microzig.Target,
STM32F103VB: *microzig.Target,
STM32F103VC: *microzig.Target,
STM32F103VD: *microzig.Target,
STM32F103VE: *microzig.Target,
STM32F103VF: *microzig.Target,
STM32F103VG: *microzig.Target,
STM32F103ZC: *microzig.Target,
STM32F103ZD: *microzig.Target,
STM32F103ZE: *microzig.Target,
STM32F103ZF: *microzig.Target,
STM32F103ZG: *microzig.Target,
STM32F105R8: *microzig.Target,
STM32F105RB: *microzig.Target,
STM32F105RC: *microzig.Target,
STM32F105V8: *microzig.Target,
STM32F105VB: *microzig.Target,
STM32F105VC: *microzig.Target,
STM32F107RB: *microzig.Target,
STM32F107RC: *microzig.Target,
STM32F107VB: *microzig.Target,
STM32F107VC: *microzig.Target,
STM32F205RB: *microzig.Target,
STM32F205RC: *microzig.Target,
STM32F205RE: *microzig.Target,
STM32F205RF: *microzig.Target,
STM32F205RG: *microzig.Target,
STM32F205VB: *microzig.Target,
STM32F205VC: *microzig.Target,
STM32F205VE: *microzig.Target,
STM32F205VF: *microzig.Target,
STM32F205VG: *microzig.Target,
STM32F205ZC: *microzig.Target,
STM32F205ZE: *microzig.Target,
STM32F205ZF: *microzig.Target,
STM32F205ZG: *microzig.Target,
STM32F207IC: *microzig.Target,
STM32F207IE: *microzig.Target,
STM32F207IF: *microzig.Target,
STM32F207IG: *microzig.Target,
STM32F207VC: *microzig.Target,
STM32F207VE: *microzig.Target,
STM32F207VF: *microzig.Target,
STM32F207VG: *microzig.Target,
STM32F207ZC: *microzig.Target,
STM32F207ZE: *microzig.Target,
STM32F207ZF: *microzig.Target,
STM32F207ZG: *microzig.Target,
STM32F215RE: *microzig.Target,
STM32F215RG: *microzig.Target,
STM32F215VE: *microzig.Target,
STM32F215VG: *microzig.Target,
STM32F215ZE: *microzig.Target,
STM32F215ZG: *microzig.Target,
STM32F217IE: *microzig.Target,
STM32F217IG: *microzig.Target,
STM32F217VE: *microzig.Target,
STM32F217VG: *microzig.Target,
STM32F217ZE: *microzig.Target,
STM32F217ZG: *microzig.Target,
STM32F301C6: *microzig.Target,
STM32F301C8: *microzig.Target,
STM32F301K6: *microzig.Target,
STM32F301K8: *microzig.Target,
STM32F301R6: *microzig.Target,
STM32F301R8: *microzig.Target,
STM32F302C6: *microzig.Target,
STM32F302C8: *microzig.Target,
STM32F302CB: *microzig.Target,
STM32F302CC: *microzig.Target,
STM32F302K6: *microzig.Target,
STM32F302K8: *microzig.Target,
STM32F302R6: *microzig.Target,
STM32F302R8: *microzig.Target,
STM32F302RB: *microzig.Target,
STM32F302RC: *microzig.Target,
STM32F302RD: *microzig.Target,
STM32F302RE: *microzig.Target,
STM32F302VB: *microzig.Target,
STM32F302VC: *microzig.Target,
STM32F302VD: *microzig.Target,
STM32F302VE: *microzig.Target,
STM32F302ZD: *microzig.Target,
STM32F302ZE: *microzig.Target,
STM32F303C6: *microzig.Target,
STM32F303C8: *microzig.Target,
STM32F303CB: *microzig.Target,
STM32F303CC: *microzig.Target,
STM32F303K6: *microzig.Target,
STM32F303K8: *microzig.Target,
STM32F303R6: *microzig.Target,
STM32F303R8: *microzig.Target,
STM32F303RB: *microzig.Target,
STM32F303RC: *microzig.Target,
STM32F303RD: *microzig.Target,
STM32F303RE: *microzig.Target,
STM32F303VB: *microzig.Target,
STM32F303VC: *microzig.Target,
STM32F303VD: *microzig.Target,
STM32F303VE: *microzig.Target,
STM32F303ZD: *microzig.Target,
STM32F303ZE: *microzig.Target,
STM32F318C8: *microzig.Target,
STM32F318K8: *microzig.Target,
STM32F328C8: *microzig.Target,
STM32F334C4: *microzig.Target,
STM32F334C6: *microzig.Target,
STM32F334C8: *microzig.Target,
STM32F334K4: *microzig.Target,
STM32F334K6: *microzig.Target,
STM32F334K8: *microzig.Target,
STM32F334R6: *microzig.Target,
STM32F334R8: *microzig.Target,
STM32F358CC: *microzig.Target,
STM32F358RC: *microzig.Target,
STM32F358VC: *microzig.Target,
STM32F373C8: *microzig.Target,
STM32F373CB: *microzig.Target,
STM32F373CC: *microzig.Target,
STM32F373R8: *microzig.Target,
STM32F373RB: *microzig.Target,
STM32F373RC: *microzig.Target,
STM32F373V8: *microzig.Target,
STM32F373VB: *microzig.Target,
STM32F373VC: *microzig.Target,
STM32F378CC: *microzig.Target,
STM32F378RC: *microzig.Target,
STM32F378VC: *microzig.Target,
STM32F398VE: *microzig.Target,
STM32F401CB: *microzig.Target,
STM32F401CC: *microzig.Target,
STM32F401CD: *microzig.Target,
STM32F401CE: *microzig.Target,
STM32F401RB: *microzig.Target,
STM32F401RC: *microzig.Target,
STM32F401RD: *microzig.Target,
STM32F401RE: *microzig.Target,
STM32F401VB: *microzig.Target,
STM32F401VC: *microzig.Target,
STM32F401VD: *microzig.Target,
STM32F401VE: *microzig.Target,
STM32F405OE: *microzig.Target,
STM32F405OG: *microzig.Target,
STM32F405RG: *microzig.Target,
STM32F405VG: *microzig.Target,
STM32F405ZG: *microzig.Target,
STM32F407IE: *microzig.Target,
STM32F407IG: *microzig.Target,
STM32F407VE: *microzig.Target,
STM32F407VG: *microzig.Target,
STM32F407ZE: *microzig.Target,
STM32F407ZG: *microzig.Target,
STM32F410C8: *microzig.Target,
STM32F410CB: *microzig.Target,
STM32F410R8: *microzig.Target,
STM32F410RB: *microzig.Target,
STM32F410T8: *microzig.Target,
STM32F410TB: *microzig.Target,
STM32F411CC: *microzig.Target,
STM32F411CE: *microzig.Target,
STM32F411RC: *microzig.Target,
STM32F411RE: *microzig.Target,
STM32F411VC: *microzig.Target,
STM32F411VE: *microzig.Target,
STM32F412CE: *microzig.Target,
STM32F412CG: *microzig.Target,
STM32F412RE: *microzig.Target,
STM32F412RG: *microzig.Target,
STM32F412VE: *microzig.Target,
STM32F412VG: *microzig.Target,
STM32F412ZE: *microzig.Target,
STM32F412ZG: *microzig.Target,
STM32F413CG: *microzig.Target,
STM32F413CH: *microzig.Target,
STM32F413MG: *microzig.Target,
STM32F413MH: *microzig.Target,
STM32F413RG: *microzig.Target,
STM32F413RH: *microzig.Target,
STM32F413VG: *microzig.Target,
STM32F413VH: *microzig.Target,
STM32F413ZG: *microzig.Target,
STM32F413ZH: *microzig.Target,
STM32F415OG: *microzig.Target,
STM32F415RG: *microzig.Target,
STM32F415VG: *microzig.Target,
STM32F415ZG: *microzig.Target,
STM32F417IE: *microzig.Target,
STM32F417IG: *microzig.Target,
STM32F417VE: *microzig.Target,
STM32F417VG: *microzig.Target,
STM32F417ZE: *microzig.Target,
STM32F417ZG: *microzig.Target,
STM32F423CH: *microzig.Target,
STM32F423MH: *microzig.Target,
STM32F423RH: *microzig.Target,
STM32F423VH: *microzig.Target,
STM32F423ZH: *microzig.Target,
STM32F427AG: *microzig.Target,
STM32F427AI: *microzig.Target,
STM32F427IG: *microzig.Target,
STM32F427II: *microzig.Target,
STM32F427VG: *microzig.Target,
STM32F427VI: *microzig.Target,
STM32F427ZG: *microzig.Target,
STM32F427ZI: *microzig.Target,
STM32F429AG: *microzig.Target,
STM32F429AI: *microzig.Target,
STM32F429BE: *microzig.Target,
STM32F429BG: *microzig.Target,
STM32F429BI: *microzig.Target,
STM32F429IE: *microzig.Target,
STM32F429IG: *microzig.Target,
STM32F429II: *microzig.Target,
STM32F429NE: *microzig.Target,
STM32F429NG: *microzig.Target,
STM32F429NI: *microzig.Target,
STM32F429VE: *microzig.Target,
STM32F429VG: *microzig.Target,
STM32F429VI: *microzig.Target,
STM32F429ZE: *microzig.Target,
STM32F429ZG: *microzig.Target,
STM32F429ZI: *microzig.Target,
STM32F437AI: *microzig.Target,
STM32F437IG: *microzig.Target,
STM32F437II: *microzig.Target,
STM32F437VG: *microzig.Target,
STM32F437VI: *microzig.Target,
STM32F437ZG: *microzig.Target,
STM32F437ZI: *microzig.Target,
STM32F439AI: *microzig.Target,
STM32F439BG: *microzig.Target,
STM32F439BI: *microzig.Target,
STM32F439IG: *microzig.Target,
STM32F439II: *microzig.Target,
STM32F439NG: *microzig.Target,
STM32F439NI: *microzig.Target,
STM32F439VG: *microzig.Target,
STM32F439VI: *microzig.Target,
STM32F439ZG: *microzig.Target,
STM32F439ZI: *microzig.Target,
STM32F446MC: *microzig.Target,
STM32F446ME: *microzig.Target,
STM32F446RC: *microzig.Target,
STM32F446RE: *microzig.Target,
STM32F446VC: *microzig.Target,
STM32F446VE: *microzig.Target,
STM32F446ZC: *microzig.Target,
STM32F446ZE: *microzig.Target,
STM32F469AE: *microzig.Target,
STM32F469AG: *microzig.Target,
STM32F469AI: *microzig.Target,
STM32F469BE: *microzig.Target,
STM32F469BG: *microzig.Target,
STM32F469BI: *microzig.Target,
STM32F469IE: *microzig.Target,
STM32F469IG: *microzig.Target,
STM32F469II: *microzig.Target,
STM32F469NE: *microzig.Target,
STM32F469NG: *microzig.Target,
STM32F469NI: *microzig.Target,
STM32F469VE: *microzig.Target,
STM32F469VG: *microzig.Target,
STM32F469VI: *microzig.Target,
STM32F469ZE: *microzig.Target,
STM32F469ZG: *microzig.Target,
STM32F469ZI: *microzig.Target,
STM32F479AG: *microzig.Target,
STM32F479AI: *microzig.Target,
STM32F479BG: *microzig.Target,
STM32F479BI: *microzig.Target,
STM32F479IG: *microzig.Target,
STM32F479II: *microzig.Target,
STM32F479NG: *microzig.Target,
STM32F479NI: *microzig.Target,
STM32F479VG: *microzig.Target,
STM32F479VI: *microzig.Target,
STM32F479ZG: *microzig.Target,
STM32F479ZI: *microzig.Target,
STM32F722IC: *microzig.Target,
STM32F722IE: *microzig.Target,
STM32F722RC: *microzig.Target,
STM32F722RE: *microzig.Target,
STM32F722VC: *microzig.Target,
STM32F722VE: *microzig.Target,
STM32F722ZC: *microzig.Target,
STM32F722ZE: *microzig.Target,
STM32F723IC: *microzig.Target,
STM32F723IE: *microzig.Target,
STM32F723VC: *microzig.Target,
STM32F723VE: *microzig.Target,
STM32F723ZC: *microzig.Target,
STM32F723ZE: *microzig.Target,
STM32F730I8: *microzig.Target,
STM32F730R8: *microzig.Target,
STM32F730V8: *microzig.Target,
STM32F730Z8: *microzig.Target,
STM32F732IE: *microzig.Target,
STM32F732RE: *microzig.Target,
STM32F732VE: *microzig.Target,
STM32F732ZE: *microzig.Target,
STM32F733IE: *microzig.Target,
STM32F733VE: *microzig.Target,
STM32F733ZE: *microzig.Target,
STM32F745IE: *microzig.Target,
STM32F745IG: *microzig.Target,
STM32F745VE: *microzig.Target,
STM32F745VG: *microzig.Target,
STM32F745ZE: *microzig.Target,
STM32F745ZG: *microzig.Target,
STM32F746BE: *microzig.Target,
STM32F746BG: *microzig.Target,
STM32F746IE: *microzig.Target,
STM32F746IG: *microzig.Target,
STM32F746NE: *microzig.Target,
STM32F746NG: *microzig.Target,
STM32F746VE: *microzig.Target,
STM32F746VG: *microzig.Target,
STM32F746ZE: *microzig.Target,
STM32F746ZG: *microzig.Target,
STM32F750N8: *microzig.Target,
STM32F750V8: *microzig.Target,
STM32F750Z8: *microzig.Target,
STM32F756BG: *microzig.Target,
STM32F756IG: *microzig.Target,
STM32F756NG: *microzig.Target,
STM32F756VG: *microzig.Target,
STM32F756ZG: *microzig.Target,
STM32F765BG: *microzig.Target,
STM32F765BI: *microzig.Target,
STM32F765IG: *microzig.Target,
STM32F765II: *microzig.Target,
STM32F765NG: *microzig.Target,
STM32F765NI: *microzig.Target,
STM32F765VG: *microzig.Target,
STM32F765VI: *microzig.Target,
STM32F765ZG: *microzig.Target,
STM32F765ZI: *microzig.Target,
STM32F767BG: *microzig.Target,
STM32F767BI: *microzig.Target,
STM32F767IG: *microzig.Target,
STM32F767II: *microzig.Target,
STM32F767NG: *microzig.Target,
STM32F767NI: *microzig.Target,
STM32F767VG: *microzig.Target,
STM32F767VI: *microzig.Target,
STM32F767ZG: *microzig.Target,
STM32F767ZI: *microzig.Target,
STM32F768AI: *microzig.Target,
STM32F769AG: *microzig.Target,
STM32F769AI: *microzig.Target,
STM32F769BG: *microzig.Target,
STM32F769BI: *microzig.Target,
STM32F769IG: *microzig.Target,
STM32F769II: *microzig.Target,
STM32F769NG: *microzig.Target,
STM32F769NI: *microzig.Target,
STM32F777BI: *microzig.Target,
STM32F777II: *microzig.Target,
STM32F777NI: *microzig.Target,
STM32F777VI: *microzig.Target,
STM32F777ZI: *microzig.Target,
STM32F778AI: *microzig.Target,
STM32F779AI: *microzig.Target,
STM32F779BI: *microzig.Target,
STM32F779II: *microzig.Target,
STM32F779NI: *microzig.Target,
STM32G030C6: *microzig.Target,
STM32G030C8: *microzig.Target,
STM32G030F6: *microzig.Target,
STM32G030J6: *microzig.Target,
STM32G030K6: *microzig.Target,
STM32G030K8: *microzig.Target,
STM32G031C4: *microzig.Target,
STM32G031C6: *microzig.Target,
STM32G031C8: *microzig.Target,
STM32G031F4: *microzig.Target,
STM32G031F6: *microzig.Target,
STM32G031F8: *microzig.Target,
STM32G031G4: *microzig.Target,
STM32G031G6: *microzig.Target,
STM32G031G8: *microzig.Target,
STM32G031J4: *microzig.Target,
STM32G031J6: *microzig.Target,
STM32G031K4: *microzig.Target,
STM32G031K6: *microzig.Target,
STM32G031K8: *microzig.Target,
STM32G031Y8: *microzig.Target,
STM32G041C6: *microzig.Target,
STM32G041C8: *microzig.Target,
STM32G041F6: *microzig.Target,
STM32G041F8: *microzig.Target,
STM32G041G6: *microzig.Target,
STM32G041G8: *microzig.Target,
STM32G041J6: *microzig.Target,
STM32G041K6: *microzig.Target,
STM32G041K8: *microzig.Target,
STM32G041Y8: *microzig.Target,
STM32G050C6: *microzig.Target,
STM32G050C8: *microzig.Target,
STM32G050F6: *microzig.Target,
STM32G050K6: *microzig.Target,
STM32G050K8: *microzig.Target,
STM32G051C6: *microzig.Target,
STM32G051C8: *microzig.Target,
STM32G051F6: *microzig.Target,
STM32G051F8: *microzig.Target,
STM32G051G6: *microzig.Target,
STM32G051G8: *microzig.Target,
STM32G051K6: *microzig.Target,
STM32G051K8: *microzig.Target,
STM32G061C6: *microzig.Target,
STM32G061C8: *microzig.Target,
STM32G061F6: *microzig.Target,
STM32G061F8: *microzig.Target,
STM32G061G6: *microzig.Target,
STM32G061G8: *microzig.Target,
STM32G061K6: *microzig.Target,
STM32G061K8: *microzig.Target,
STM32G070CB: *microzig.Target,
STM32G070KB: *microzig.Target,
STM32G070RB: *microzig.Target,
STM32G071C6: *microzig.Target,
STM32G071C8: *microzig.Target,
STM32G071CB: *microzig.Target,
STM32G071EB: *microzig.Target,
STM32G071G6: *microzig.Target,
STM32G071G8: *microzig.Target,
STM32G071GB: *microzig.Target,
STM32G071K6: *microzig.Target,
STM32G071K8: *microzig.Target,
STM32G071KB: *microzig.Target,
STM32G071R6: *microzig.Target,
STM32G071R8: *microzig.Target,
STM32G071RB: *microzig.Target,
STM32G081CB: *microzig.Target,
STM32G081EB: *microzig.Target,
STM32G081GB: *microzig.Target,
STM32G081KB: *microzig.Target,
STM32G081RB: *microzig.Target,
STM32G0B0CE: *microzig.Target,
STM32G0B0KE: *microzig.Target,
STM32G0B0RE: *microzig.Target,
STM32G0B0VE: *microzig.Target,
STM32G0B1CB: *microzig.Target,
STM32G0B1CC: *microzig.Target,
STM32G0B1CE: *microzig.Target,
STM32G0B1KB: *microzig.Target,
STM32G0B1KC: *microzig.Target,
STM32G0B1KE: *microzig.Target,
STM32G0B1MB: *microzig.Target,
STM32G0B1MC: *microzig.Target,
STM32G0B1ME: *microzig.Target,
STM32G0B1NE: *microzig.Target,
STM32G0B1RB: *microzig.Target,
STM32G0B1RC: *microzig.Target,
STM32G0B1RE: *microzig.Target,
STM32G0B1VB: *microzig.Target,
STM32G0B1VC: *microzig.Target,
STM32G0B1VE: *microzig.Target,
STM32G0C1CC: *microzig.Target,
STM32G0C1CE: *microzig.Target,
STM32G0C1KC: *microzig.Target,
STM32G0C1KE: *microzig.Target,
STM32G0C1MC: *microzig.Target,
STM32G0C1ME: *microzig.Target,
STM32G0C1NE: *microzig.Target,
STM32G0C1RC: *microzig.Target,
STM32G0C1RE: *microzig.Target,
STM32G0C1VC: *microzig.Target,
STM32G0C1VE: *microzig.Target,
STM32G431C6: *microzig.Target,
STM32G431C8: *microzig.Target,
STM32G431CB: *microzig.Target,
STM32G431K6: *microzig.Target,
STM32G431K8: *microzig.Target,
STM32G431KB: *microzig.Target,
STM32G431M6: *microzig.Target,
STM32G431M8: *microzig.Target,
STM32G431MB: *microzig.Target,
STM32G431R6: *microzig.Target,
STM32G431R8: *microzig.Target,
STM32G431RB: *microzig.Target,
STM32G431V6: *microzig.Target,
STM32G431V8: *microzig.Target,
STM32G431VB: *microzig.Target,
STM32G441CB: *microzig.Target,
STM32G441KB: *microzig.Target,
STM32G441MB: *microzig.Target,
STM32G441RB: *microzig.Target,
STM32G441VB: *microzig.Target,
STM32G471CC: *microzig.Target,
STM32G471CE: *microzig.Target,
STM32G471MC: *microzig.Target,
STM32G471ME: *microzig.Target,
STM32G471QC: *microzig.Target,
STM32G471QE: *microzig.Target,
STM32G471RC: *microzig.Target,
STM32G471RE: *microzig.Target,
STM32G471VC: *microzig.Target,
STM32G471VE: *microzig.Target,
STM32G473CB: *microzig.Target,
STM32G473CC: *microzig.Target,
STM32G473CE: *microzig.Target,
STM32G473MB: *microzig.Target,
STM32G473MC: *microzig.Target,
STM32G473ME: *microzig.Target,
STM32G473PB: *microzig.Target,
STM32G473PC: *microzig.Target,
STM32G473PE: *microzig.Target,
STM32G473QB: *microzig.Target,
STM32G473QC: *microzig.Target,
STM32G473QE: *microzig.Target,
STM32G473RB: *microzig.Target,
STM32G473RC: *microzig.Target,
STM32G473RE: *microzig.Target,
STM32G473VB: *microzig.Target,
STM32G473VC: *microzig.Target,
STM32G473VE: *microzig.Target,
STM32G474CB: *microzig.Target,
STM32G474CC: *microzig.Target,
STM32G474CE: *microzig.Target,
STM32G474MB: *microzig.Target,
STM32G474MC: *microzig.Target,
STM32G474ME: *microzig.Target,
STM32G474PB: *microzig.Target,
STM32G474PC: *microzig.Target,
STM32G474PE: *microzig.Target,
STM32G474QB: *microzig.Target,
STM32G474QC: *microzig.Target,
STM32G474QE: *microzig.Target,
STM32G474RB: *microzig.Target,
STM32G474RC: *microzig.Target,
STM32G474RE: *microzig.Target,
STM32G474VB: *microzig.Target,
STM32G474VC: *microzig.Target,
STM32G474VE: *microzig.Target,
STM32G483CE: *microzig.Target,
STM32G483ME: *microzig.Target,
STM32G483PE: *microzig.Target,
STM32G483QE: *microzig.Target,
STM32G483RE: *microzig.Target,
STM32G483VE: *microzig.Target,
STM32G484CE: *microzig.Target,
STM32G484ME: *microzig.Target,
STM32G484PE: *microzig.Target,
STM32G484QE: *microzig.Target,
STM32G484RE: *microzig.Target,
STM32G484VE: *microzig.Target,
STM32G491CC: *microzig.Target,
STM32G491CE: *microzig.Target,
STM32G491KC: *microzig.Target,
STM32G491KE: *microzig.Target,
STM32G491MC: *microzig.Target,
STM32G491ME: *microzig.Target,
STM32G491RC: *microzig.Target,
STM32G491RE: *microzig.Target,
STM32G491VC: *microzig.Target,
STM32G491VE: *microzig.Target,
STM32G4A1CE: *microzig.Target,
STM32G4A1KE: *microzig.Target,
STM32G4A1ME: *microzig.Target,
STM32G4A1RE: *microzig.Target,
STM32G4A1VE: *microzig.Target,
STM32H503CB: *microzig.Target,
STM32H503EB: *microzig.Target,
STM32H503KB: *microzig.Target,
STM32H503RB: *microzig.Target,
STM32H523CC: *microzig.Target,
STM32H523CE: *microzig.Target,
STM32H523HE: *microzig.Target,
STM32H523RC: *microzig.Target,
STM32H523RE: *microzig.Target,
STM32H523VC: *microzig.Target,
STM32H523VE: *microzig.Target,
STM32H523ZC: *microzig.Target,
STM32H523ZE: *microzig.Target,
STM32H533CE: *microzig.Target,
STM32H533HE: *microzig.Target,
STM32H533RE: *microzig.Target,
STM32H533VE: *microzig.Target,
STM32H533ZE: *microzig.Target,
STM32H562AG: *microzig.Target,
STM32H562AI: *microzig.Target,
STM32H562IG: *microzig.Target,
STM32H562II: *microzig.Target,
STM32H562RG: *microzig.Target,
STM32H562RI: *microzig.Target,
STM32H562VG: *microzig.Target,
STM32H562VI: *microzig.Target,
STM32H562ZG: *microzig.Target,
STM32H562ZI: *microzig.Target,
STM32H563AG: *microzig.Target,
STM32H563AI: *microzig.Target,
STM32H563IG: *microzig.Target,
STM32H563II: *microzig.Target,
STM32H563MI: *microzig.Target,
STM32H563RG: *microzig.Target,
STM32H563RI: *microzig.Target,
STM32H563VG: *microzig.Target,
STM32H563VI: *microzig.Target,
STM32H563ZG: *microzig.Target,
STM32H563ZI: *microzig.Target,
STM32H573AI: *microzig.Target,
STM32H573II: *microzig.Target,
STM32H573MI: *microzig.Target,
STM32H573RI: *microzig.Target,
STM32H573VI: *microzig.Target,
STM32H573ZI: *microzig.Target,
STM32H723VE: *microzig.Target,
STM32H723VG: *microzig.Target,
STM32H723ZE: *microzig.Target,
STM32H723ZG: *microzig.Target,
STM32H725AE: *microzig.Target,
STM32H725AG: *microzig.Target,
STM32H725IE: *microzig.Target,
STM32H725IG: *microzig.Target,
STM32H725RE: *microzig.Target,
STM32H725RG: *microzig.Target,
STM32H725VE: *microzig.Target,
STM32H725VG: *microzig.Target,
STM32H725ZE: *microzig.Target,
STM32H725ZG: *microzig.Target,
STM32H730AB: *microzig.Target,
STM32H730IB: *microzig.Target,
STM32H730VB: *microzig.Target,
STM32H730ZB: *microzig.Target,
STM32H733VG: *microzig.Target,
STM32H733ZG: *microzig.Target,
STM32H735AG: *microzig.Target,
STM32H735IG: *microzig.Target,
STM32H735RG: *microzig.Target,
STM32H735VG: *microzig.Target,
STM32H735ZG: *microzig.Target,
STM32H742AG: *microzig.Target,
STM32H742AI: *microzig.Target,
STM32H742BG: *microzig.Target,
STM32H742BI: *microzig.Target,
STM32H742IG: *microzig.Target,
STM32H742II: *microzig.Target,
STM32H742VG: *microzig.Target,
STM32H742VI: *microzig.Target,
STM32H742XG: *microzig.Target,
STM32H742XI: *microzig.Target,
STM32H742ZG: *microzig.Target,
STM32H742ZI: *microzig.Target,
STM32H743AG: *microzig.Target,
STM32H743AI: *microzig.Target,
STM32H743BG: *microzig.Target,
STM32H743BI: *microzig.Target,
STM32H743IG: *microzig.Target,
STM32H743II: *microzig.Target,
STM32H743VG: *microzig.Target,
STM32H743VI: *microzig.Target,
STM32H743XG: *microzig.Target,
STM32H743XI: *microzig.Target,
STM32H743ZG: *microzig.Target,
STM32H743ZI: *microzig.Target,
STM32H745BG: *microzig.Target,
STM32H745BI: *microzig.Target,
STM32H745IG: *microzig.Target,
STM32H745II: *microzig.Target,
STM32H745XG: *microzig.Target,
STM32H745XI: *microzig.Target,
STM32H745ZG: *microzig.Target,
STM32H745ZI: *microzig.Target,
STM32H747AG: *microzig.Target,
STM32H747AI: *microzig.Target,
STM32H747BG: *microzig.Target,
STM32H747BI: *microzig.Target,
STM32H747IG: *microzig.Target,
STM32H747II: *microzig.Target,
STM32H747XG: *microzig.Target,
STM32H747XI: *microzig.Target,
STM32H747ZI: *microzig.Target,
STM32H750IB: *microzig.Target,
STM32H750VB: *microzig.Target,
STM32H750XB: *microzig.Target,
STM32H750ZB: *microzig.Target,
STM32H753AI: *microzig.Target,
STM32H753BI: *microzig.Target,
STM32H753II: *microzig.Target,
STM32H753VI: *microzig.Target,
STM32H753XI: *microzig.Target,
STM32H753ZI: *microzig.Target,
STM32H755BI: *microzig.Target,
STM32H755II: *microzig.Target,
STM32H755XI: *microzig.Target,
STM32H755ZI: *microzig.Target,
STM32H757AI: *microzig.Target,
STM32H757BI: *microzig.Target,
STM32H757II: *microzig.Target,
STM32H757XI: *microzig.Target,
STM32H757ZI: *microzig.Target,
STM32H7A3AG: *microzig.Target,
STM32H7A3AI: *microzig.Target,
STM32H7A3IG: *microzig.Target,
STM32H7A3II: *microzig.Target,
STM32H7A3LG: *microzig.Target,
STM32H7A3LI: *microzig.Target,
STM32H7A3NG: *microzig.Target,
STM32H7A3NI: *microzig.Target,
STM32H7A3QI: *microzig.Target,
STM32H7A3RG: *microzig.Target,
STM32H7A3RI: *microzig.Target,
STM32H7A3VG: *microzig.Target,
STM32H7A3VI: *microzig.Target,
STM32H7A3ZG: *microzig.Target,
STM32H7A3ZI: *microzig.Target,
STM32H7B0AB: *microzig.Target,
STM32H7B0IB: *microzig.Target,
STM32H7B0RB: *microzig.Target,
STM32H7B0VB: *microzig.Target,
STM32H7B0ZB: *microzig.Target,
STM32H7B3AI: *microzig.Target,
STM32H7B3II: *microzig.Target,
STM32H7B3LI: *microzig.Target,
STM32H7B3NI: *microzig.Target,
STM32H7B3QI: *microzig.Target,
STM32H7B3RI: *microzig.Target,
STM32H7B3VI: *microzig.Target,
STM32H7B3ZI: *microzig.Target,
STM32H7R3A8: *microzig.Target,
STM32H7R3I8: *microzig.Target,
STM32H7R3L8: *microzig.Target,
STM32H7R3R8: *microzig.Target,
STM32H7R3V8: *microzig.Target,
STM32H7R3Z8: *microzig.Target,
STM32H7R7A8: *microzig.Target,
STM32H7R7I8: *microzig.Target,
STM32H7R7L8: *microzig.Target,
STM32H7R7Z8: *microzig.Target,
STM32H7S3A8: *microzig.Target,
STM32H7S3I8: *microzig.Target,
STM32H7S3L8: *microzig.Target,
STM32H7S3R8: *microzig.Target,
STM32H7S3V8: *microzig.Target,
STM32H7S3Z8: *microzig.Target,
STM32H7S7A8: *microzig.Target,
STM32H7S7I8: *microzig.Target,
STM32H7S7L8: *microzig.Target,
STM32H7S7Z8: *microzig.Target,
STM32L010C6: *microzig.Target,
STM32L010F4: *microzig.Target,
STM32L010K4: *microzig.Target,
STM32L010K8: *microzig.Target,
STM32L010R8: *microzig.Target,
STM32L010RB: *microzig.Target,
STM32L011D3: *microzig.Target,
STM32L011D4: *microzig.Target,
STM32L011E3: *microzig.Target,
STM32L011E4: *microzig.Target,
STM32L011F3: *microzig.Target,
STM32L011F4: *microzig.Target,
STM32L011G3: *microzig.Target,
STM32L011G4: *microzig.Target,
STM32L011K3: *microzig.Target,
STM32L011K4: *microzig.Target,
STM32L021D4: *microzig.Target,
STM32L021F4: *microzig.Target,
STM32L021G4: *microzig.Target,
STM32L021K4: *microzig.Target,
STM32L031C4: *microzig.Target,
STM32L031C6: *microzig.Target,
STM32L031E4: *microzig.Target,
STM32L031E6: *microzig.Target,
STM32L031F4: *microzig.Target,
STM32L031F6: *microzig.Target,
STM32L031G4: *microzig.Target,
STM32L031G6: *microzig.Target,
STM32L031K4: *microzig.Target,
STM32L031K6: *microzig.Target,
STM32L041C4: *microzig.Target,
STM32L041C6: *microzig.Target,
STM32L041E6: *microzig.Target,
STM32L041F6: *microzig.Target,
STM32L041G6: *microzig.Target,
STM32L041K6: *microzig.Target,
STM32L051C6: *microzig.Target,
STM32L051C8: *microzig.Target,
STM32L051K6: *microzig.Target,
STM32L051K8: *microzig.Target,
STM32L051R6: *microzig.Target,
STM32L051R8: *microzig.Target,
STM32L051T6: *microzig.Target,
STM32L051T8: *microzig.Target,
STM32L052C6: *microzig.Target,
STM32L052C8: *microzig.Target,
STM32L052K6: *microzig.Target,
STM32L052K8: *microzig.Target,
STM32L052R6: *microzig.Target,
STM32L052R8: *microzig.Target,
STM32L052T6: *microzig.Target,
STM32L052T8: *microzig.Target,
STM32L053C6: *microzig.Target,
STM32L053C8: *microzig.Target,
STM32L053R6: *microzig.Target,
STM32L053R8: *microzig.Target,
STM32L062C8: *microzig.Target,
STM32L062K8: *microzig.Target,
STM32L063C8: *microzig.Target,
STM32L063R8: *microzig.Target,
STM32L071C8: *microzig.Target,
STM32L071CB: *microzig.Target,
STM32L071CZ: *microzig.Target,
STM32L071K8: *microzig.Target,
STM32L071KB: *microzig.Target,
STM32L071KZ: *microzig.Target,
STM32L071RB: *microzig.Target,
STM32L071RZ: *microzig.Target,
STM32L071V8: *microzig.Target,
STM32L071VB: *microzig.Target,
STM32L071VZ: *microzig.Target,
STM32L072CB: *microzig.Target,
STM32L072CZ: *microzig.Target,
STM32L072KB: *microzig.Target,
STM32L072KZ: *microzig.Target,
STM32L072RB: *microzig.Target,
STM32L072RZ: *microzig.Target,
STM32L072V8: *microzig.Target,
STM32L072VB: *microzig.Target,
STM32L072VZ: *microzig.Target,
STM32L073CB: *microzig.Target,
STM32L073CZ: *microzig.Target,
STM32L073RB: *microzig.Target,
STM32L073RZ: *microzig.Target,
STM32L073V8: *microzig.Target,
STM32L073VB: *microzig.Target,
STM32L073VZ: *microzig.Target,
STM32L081CB: *microzig.Target,
STM32L081CZ: *microzig.Target,
STM32L081KZ: *microzig.Target,
STM32L082CZ: *microzig.Target,
STM32L082KB: *microzig.Target,
STM32L082KZ: *microzig.Target,
STM32L083CB: *microzig.Target,
STM32L083CZ: *microzig.Target,
STM32L083RB: *microzig.Target,
STM32L083RZ: *microzig.Target,
STM32L083V8: *microzig.Target,
STM32L083VB: *microzig.Target,
STM32L083VZ: *microzig.Target,
STM32L100C6: *microzig.Target,
@"STM32L100C6-A": *microzig.Target,
STM32L100R8: *microzig.Target,
@"STM32L100R8-A": *microzig.Target,
STM32L100RB: *microzig.Target,
@"STM32L100RB-A": *microzig.Target,
STM32L100RC: *microzig.Target,
STM32L151C6: *microzig.Target,
@"STM32L151C6-A": *microzig.Target,
STM32L151C8: *microzig.Target,
@"STM32L151C8-A": *microzig.Target,
STM32L151CB: *microzig.Target,
@"STM32L151CB-A": *microzig.Target,
STM32L151CC: *microzig.Target,
STM32L151QC: *microzig.Target,
STM32L151QD: *microzig.Target,
STM32L151QE: *microzig.Target,
STM32L151R6: *microzig.Target,
@"STM32L151R6-A": *microzig.Target,
STM32L151R8: *microzig.Target,
@"STM32L151R8-A": *microzig.Target,
STM32L151RB: *microzig.Target,
@"STM32L151RB-A": *microzig.Target,
STM32L151RC: *microzig.Target,
@"STM32L151RC-A": *microzig.Target,
STM32L151RD: *microzig.Target,
STM32L151RE: *microzig.Target,
STM32L151UC: *microzig.Target,
STM32L151V8: *microzig.Target,
@"STM32L151V8-A": *microzig.Target,
STM32L151VB: *microzig.Target,
@"STM32L151VB-A": *microzig.Target,
STM32L151VC: *microzig.Target,
@"STM32L151VC-A": *microzig.Target,
STM32L151VD: *microzig.Target,
@"STM32L151VD-X": *microzig.Target,
STM32L151VE: *microzig.Target,
STM32L151ZC: *microzig.Target,
STM32L151ZD: *microzig.Target,
STM32L151ZE: *microzig.Target,
STM32L152C6: *microzig.Target,
@"STM32L152C6-A": *microzig.Target,
STM32L152C8: *microzig.Target,
@"STM32L152C8-A": *microzig.Target,
STM32L152CB: *microzig.Target,
@"STM32L152CB-A": *microzig.Target,
STM32L152CC: *microzig.Target,
STM32L152QC: *microzig.Target,
STM32L152QD: *microzig.Target,
STM32L152QE: *microzig.Target,
STM32L152R6: *microzig.Target,
@"STM32L152R6-A": *microzig.Target,
STM32L152R8: *microzig.Target,
@"STM32L152R8-A": *microzig.Target,
STM32L152RB: *microzig.Target,
@"STM32L152RB-A": *microzig.Target,
STM32L152RC: *microzig.Target,
@"STM32L152RC-A": *microzig.Target,
STM32L152RD: *microzig.Target,
STM32L152RE: *microzig.Target,
STM32L152UC: *microzig.Target,
STM32L152V8: *microzig.Target,
@"STM32L152V8-A": *microzig.Target,
STM32L152VB: *microzig.Target,
@"STM32L152VB-A": *microzig.Target,
STM32L152VC: *microzig.Target,
@"STM32L152VC-A": *microzig.Target,
STM32L152VD: *microzig.Target,
@"STM32L152VD-X": *microzig.Target,
STM32L152VE: *microzig.Target,
STM32L152ZC: *microzig.Target,
STM32L152ZD: *microzig.Target,
STM32L152ZE: *microzig.Target,
STM32L162QC: *microzig.Target,
STM32L162QD: *microzig.Target,
STM32L162RC: *microzig.Target,
@"STM32L162RC-A": *microzig.Target,
STM32L162RD: *microzig.Target,
STM32L162RE: *microzig.Target,
STM32L162VC: *microzig.Target,
@"STM32L162VC-A": *microzig.Target,
STM32L162VD: *microzig.Target,
@"STM32L162VD-X": *microzig.Target,
STM32L162VE: *microzig.Target,
STM32L162ZC: *microzig.Target,
STM32L162ZD: *microzig.Target,
STM32L162ZE: *microzig.Target,
STM32L412C8: *microzig.Target,
STM32L412CB: *microzig.Target,
STM32L412K8: *microzig.Target,
STM32L412KB: *microzig.Target,
STM32L412R8: *microzig.Target,
STM32L412RB: *microzig.Target,
STM32L412T8: *microzig.Target,
STM32L412TB: *microzig.Target,
STM32L422CB: *microzig.Target,
STM32L422KB: *microzig.Target,
STM32L422RB: *microzig.Target,
STM32L422TB: *microzig.Target,
STM32L431CB: *microzig.Target,
STM32L431CC: *microzig.Target,
STM32L431KB: *microzig.Target,
STM32L431KC: *microzig.Target,
STM32L431RB: *microzig.Target,
STM32L431RC: *microzig.Target,
STM32L431VC: *microzig.Target,
STM32L432KB: *microzig.Target,
STM32L432KC: *microzig.Target,
STM32L433CB: *microzig.Target,
STM32L433CC: *microzig.Target,
STM32L433RB: *microzig.Target,
STM32L433RC: *microzig.Target,
STM32L433VC: *microzig.Target,
STM32L442KC: *microzig.Target,
STM32L443CC: *microzig.Target,
STM32L443RC: *microzig.Target,
STM32L443VC: *microzig.Target,
STM32L451CC: *microzig.Target,
STM32L451CE: *microzig.Target,
STM32L451RC: *microzig.Target,
STM32L451RE: *microzig.Target,
STM32L451VC: *microzig.Target,
STM32L451VE: *microzig.Target,
STM32L452CC: *microzig.Target,
STM32L452CE: *microzig.Target,
STM32L452RC: *microzig.Target,
STM32L452RE: *microzig.Target,
STM32L452VC: *microzig.Target,
STM32L452VE: *microzig.Target,
STM32L462CE: *microzig.Target,
STM32L462RE: *microzig.Target,
STM32L462VE: *microzig.Target,
STM32L471QE: *microzig.Target,
STM32L471QG: *microzig.Target,
STM32L471RE: *microzig.Target,
STM32L471RG: *microzig.Target,
STM32L471VE: *microzig.Target,
STM32L471VG: *microzig.Target,
STM32L471ZE: *microzig.Target,
STM32L471ZG: *microzig.Target,
STM32L475RC: *microzig.Target,
STM32L475RE: *microzig.Target,
STM32L475RG: *microzig.Target,
STM32L475VC: *microzig.Target,
STM32L475VE: *microzig.Target,
STM32L475VG: *microzig.Target,
STM32L476JE: *microzig.Target,
STM32L476JG: *microzig.Target,
STM32L476ME: *microzig.Target,
STM32L476MG: *microzig.Target,
STM32L476QE: *microzig.Target,
STM32L476QG: *microzig.Target,
STM32L476RC: *microzig.Target,
STM32L476RE: *microzig.Target,
STM32L476RG: *microzig.Target,
STM32L476VC: *microzig.Target,
STM32L476VE: *microzig.Target,
STM32L476VG: *microzig.Target,
STM32L476ZE: *microzig.Target,
STM32L476ZG: *microzig.Target,
STM32L486JG: *microzig.Target,
STM32L486QG: *microzig.Target,
STM32L486RG: *microzig.Target,
STM32L486VG: *microzig.Target,
STM32L486ZG: *microzig.Target,
STM32L496AE: *microzig.Target,
STM32L496AG: *microzig.Target,
STM32L496QE: *microzig.Target,
STM32L496QG: *microzig.Target,
STM32L496RE: *microzig.Target,
STM32L496RG: *microzig.Target,
STM32L496VE: *microzig.Target,
STM32L496VG: *microzig.Target,
STM32L496WG: *microzig.Target,
STM32L496ZE: *microzig.Target,
STM32L496ZG: *microzig.Target,
STM32L4A6AG: *microzig.Target,
STM32L4A6QG: *microzig.Target,
STM32L4A6RG: *microzig.Target,
STM32L4A6VG: *microzig.Target,
STM32L4A6ZG: *microzig.Target,
STM32L4P5AE: *microzig.Target,
STM32L4P5AG: *microzig.Target,
STM32L4P5CE: *microzig.Target,
STM32L4P5CG: *microzig.Target,
STM32L4P5QE: *microzig.Target,
STM32L4P5QG: *microzig.Target,
STM32L4P5RE: *microzig.Target,
STM32L4P5RG: *microzig.Target,
STM32L4P5VE: *microzig.Target,
STM32L4P5VG: *microzig.Target,
STM32L4P5ZE: *microzig.Target,
STM32L4P5ZG: *microzig.Target,
STM32L4Q5AG: *microzig.Target,
STM32L4Q5CG: *microzig.Target,
STM32L4Q5QG: *microzig.Target,
STM32L4Q5RG: *microzig.Target,
STM32L4Q5VG: *microzig.Target,
STM32L4Q5ZG: *microzig.Target,
STM32L4R5AG: *microzig.Target,
STM32L4R5AI: *microzig.Target,
STM32L4R5QG: *microzig.Target,
STM32L4R5QI: *microzig.Target,
STM32L4R5VG: *microzig.Target,
STM32L4R5VI: *microzig.Target,
STM32L4R5ZG: *microzig.Target,
STM32L4R5ZI: *microzig.Target,
STM32L4R7AI: *microzig.Target,
STM32L4R7VI: *microzig.Target,
STM32L4R7ZI: *microzig.Target,
STM32L4R9AG: *microzig.Target,
STM32L4R9AI: *microzig.Target,
STM32L4R9VG: *microzig.Target,
STM32L4R9VI: *microzig.Target,
STM32L4R9ZG: *microzig.Target,
STM32L4R9ZI: *microzig.Target,
STM32L4S5AI: *microzig.Target,
STM32L4S5QI: *microzig.Target,
STM32L4S5VI: *microzig.Target,
STM32L4S5ZI: *microzig.Target,
STM32L4S7AI: *microzig.Target,
STM32L4S7VI: *microzig.Target,
STM32L4S7ZI: *microzig.Target,
STM32L4S9AI: *microzig.Target,
STM32L4S9VI: *microzig.Target,
STM32L4S9ZI: *microzig.Target,
STM32L552CC: *microzig.Target,
STM32L552CE: *microzig.Target,
STM32L552ME: *microzig.Target,
STM32L552QC: *microzig.Target,
STM32L552QE: *microzig.Target,
STM32L552RC: *microzig.Target,
STM32L552RE: *microzig.Target,
STM32L552VC: *microzig.Target,
STM32L552VE: *microzig.Target,
STM32L552ZC: *microzig.Target,
STM32L552ZE: *microzig.Target,
STM32L562CE: *microzig.Target,
STM32L562ME: *microzig.Target,
STM32L562QE: *microzig.Target,
STM32L562RE: *microzig.Target,
STM32L562VE: *microzig.Target,
STM32L562ZE: *microzig.Target,
STM32U031C6: *microzig.Target,
STM32U031C8: *microzig.Target,
STM32U031F4: *microzig.Target,
STM32U031F6: *microzig.Target,
STM32U031F8: *microzig.Target,
STM32U031G6: *microzig.Target,
STM32U031G8: *microzig.Target,
STM32U031K4: *microzig.Target,
STM32U031K6: *microzig.Target,
STM32U031K8: *microzig.Target,
STM32U031R6: *microzig.Target,
STM32U031R8: *microzig.Target,
STM32U073C8: *microzig.Target,
STM32U073CB: *microzig.Target,
STM32U073CC: *microzig.Target,
STM32U073H8: *microzig.Target,
STM32U073HB: *microzig.Target,
STM32U073HC: *microzig.Target,
STM32U073K8: *microzig.Target,
STM32U073KB: *microzig.Target,
STM32U073KC: *microzig.Target,
STM32U073M8: *microzig.Target,
STM32U073MB: *microzig.Target,
STM32U073MC: *microzig.Target,
STM32U073R8: *microzig.Target,
STM32U073RB: *microzig.Target,
STM32U073RC: *microzig.Target,
STM32U083CC: *microzig.Target,
STM32U083HC: *microzig.Target,
STM32U083KC: *microzig.Target,
STM32U083MC: *microzig.Target,
STM32U083RC: *microzig.Target,
STM32U535CB: *microzig.Target,
STM32U535CC: *microzig.Target,
STM32U535CE: *microzig.Target,
STM32U535JE: *microzig.Target,
STM32U535NC: *microzig.Target,
STM32U535NE: *microzig.Target,
STM32U535RB: *microzig.Target,
STM32U535RC: *microzig.Target,
STM32U535RE: *microzig.Target,
STM32U535VC: *microzig.Target,
STM32U535VE: *microzig.Target,
STM32U545CE: *microzig.Target,
STM32U545JE: *microzig.Target,
STM32U545NE: *microzig.Target,
STM32U545RE: *microzig.Target,
STM32U545VE: *microzig.Target,
STM32U575AG: *microzig.Target,
STM32U575AI: *microzig.Target,
STM32U575CG: *microzig.Target,
STM32U575CI: *microzig.Target,
STM32U575OG: *microzig.Target,
STM32U575OI: *microzig.Target,
STM32U575QG: *microzig.Target,
STM32U575QI: *microzig.Target,
STM32U575RG: *microzig.Target,
STM32U575RI: *microzig.Target,
STM32U575VG: *microzig.Target,
STM32U575VI: *microzig.Target,
STM32U575ZG: *microzig.Target,
STM32U575ZI: *microzig.Target,
STM32U585AI: *microzig.Target,
STM32U585CI: *microzig.Target,
STM32U585OI: *microzig.Target,
STM32U585QI: *microzig.Target,
STM32U585RI: *microzig.Target,
STM32U585VI: *microzig.Target,
STM32U585ZI: *microzig.Target,
STM32U595AI: *microzig.Target,
STM32U595AJ: *microzig.Target,
STM32U595QI: *microzig.Target,
STM32U595QJ: *microzig.Target,
STM32U595RI: *microzig.Target,
STM32U595RJ: *microzig.Target,
STM32U595VI: *microzig.Target,
STM32U595VJ: *microzig.Target,
STM32U595ZI: *microzig.Target,
STM32U595ZJ: *microzig.Target,
STM32U599BJ: *microzig.Target,
STM32U599NI: *microzig.Target,
STM32U599NJ: *microzig.Target,
STM32U599VI: *microzig.Target,
STM32U599VJ: *microzig.Target,
STM32U599ZI: *microzig.Target,
STM32U599ZJ: *microzig.Target,
STM32U5A5AJ: *microzig.Target,
STM32U5A5QI: *microzig.Target,
STM32U5A5QJ: *microzig.Target,
STM32U5A5RJ: *microzig.Target,
STM32U5A5VJ: *microzig.Target,
STM32U5A5ZJ: *microzig.Target,
STM32U5A9BJ: *microzig.Target,
STM32U5A9NJ: *microzig.Target,
STM32U5A9VJ: *microzig.Target,
STM32U5A9ZJ: *microzig.Target,
STM32U5F7VI: *microzig.Target,
STM32U5F7VJ: *microzig.Target,
STM32U5F9BJ: *microzig.Target,
STM32U5F9NJ: *microzig.Target,
STM32U5F9VI: *microzig.Target,
STM32U5F9VJ: *microzig.Target,
STM32U5F9ZI: *microzig.Target,
STM32U5F9ZJ: *microzig.Target,
STM32U5G7VJ: *microzig.Target,
STM32U5G9BJ: *microzig.Target,
STM32U5G9NJ: *microzig.Target,
STM32U5G9VJ: *microzig.Target,
STM32U5G9ZJ: *microzig.Target,
STM32WB10CC: *microzig.Target,
STM32WB15CC: *microzig.Target,
STM32WB30CE: *microzig.Target,
STM32WB35CC: *microzig.Target,
STM32WB35CE: *microzig.Target,
STM32WB50CG: *microzig.Target,
STM32WB55CC: *microzig.Target,
STM32WB55CE: *microzig.Target,
STM32WB55CG: *microzig.Target,
STM32WB55RC: *microzig.Target,
STM32WB55RE: *microzig.Target,
STM32WB55RG: *microzig.Target,
STM32WB55VC: *microzig.Target,
STM32WB55VE: *microzig.Target,
STM32WB55VG: *microzig.Target,
STM32WB55VY: *microzig.Target,
STM32WBA50KE: *microzig.Target,
STM32WBA50KG: *microzig.Target,
STM32WBA52CE: *microzig.Target,
STM32WBA52CG: *microzig.Target,
STM32WBA52KE: *microzig.Target,
STM32WBA52KG: *microzig.Target,
STM32WBA54CE: *microzig.Target,
STM32WBA54CG: *microzig.Target,
STM32WBA54KE: *microzig.Target,
STM32WBA54KG: *microzig.Target,
STM32WBA55CE: *microzig.Target,
STM32WBA55CG: *microzig.Target,
STM32WBA55HE: *microzig.Target,
STM32WBA55HG: *microzig.Target,
STM32WBA55UE: *microzig.Target,
STM32WBA55UG: *microzig.Target,
STM32WL54CC: *microzig.Target,
STM32WL54JC: *microzig.Target,
STM32WL55CC: *microzig.Target,
STM32WL55JC: *microzig.Target,
STM32WLE4C8: *microzig.Target,
STM32WLE4CB: *microzig.Target,
STM32WLE4CC: *microzig.Target,
STM32WLE4J8: *microzig.Target,
STM32WLE4JB: *microzig.Target,
STM32WLE4JC: *microzig.Target,
STM32WLE5C8: *microzig.Target,
STM32WLE5CB: *microzig.Target,
STM32WLE5CC: *microzig.Target,
STM32WLE5J8: *microzig.Target,
STM32WLE5JB: *microzig.Target,
STM32WLE5JC: *microzig.Target,

pub fn init(dep: *std.Build.Dependency, hal_imports: []std.Build.Module.Import) Self {
    const b = dep.builder;
    const embassy = b.dependency("stm32-data-generated", .{}).path(".");
    var ret: Self = undefined;

    ret.STM32C011D6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32C011D6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32C011D6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32C011D6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32C011F4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32C011F4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32C011F4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32C011F4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32C011F6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32C011F6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32C011F6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32C011F6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32C011J4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32C011J4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32C011J4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32C011J4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32C011J6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32C011J6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32C011J6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32C011J6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32C031C4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32C031C4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32C031C4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32C031C4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x3000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32C031C6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32C031C6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32C031C6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32C031C6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x3000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32C031F4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32C031F4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32C031F4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32C031F4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x3000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32C031F6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32C031F6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32C031F6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32C031F6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x3000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32C031G4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32C031G4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32C031G4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32C031G4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x3000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32C031G6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32C031G6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32C031G6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32C031G6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x3000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32C031K4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32C031K4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32C031K4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32C031K4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x3000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32C031K6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32C031K6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32C031K6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32C031K6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x3000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F030C6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F030C6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F030C6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F030C6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F030C8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F030C8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F030C8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F030C8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F030CC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F030CC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F030CC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F030CC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F030F4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F030F4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F030F4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F030F4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F030K6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F030K6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F030K6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F030K6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F030R8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F030R8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F030R8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F030R8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F030RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F030RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F030RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F030RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F031C4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F031C4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F031C4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F031C4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F031C6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F031C6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F031C6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F031C6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F031E6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F031E6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F031E6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F031E6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F031F4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F031F4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F031F4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F031F4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F031F6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F031F6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F031F6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F031F6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F031G4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F031G4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F031G4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F031G4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F031G6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F031G6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F031G6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F031G6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F031K4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F031K4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F031K4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F031K4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F031K6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F031K6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F031K6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F031K6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F038C6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F038C6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F038C6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F038C6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F038E6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F038E6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F038E6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F038E6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F038F6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F038F6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F038F6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F038F6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F038G6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F038G6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F038G6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F038G6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F038K6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F038K6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F038K6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F038K6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F042C4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F042C4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F042C4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F042C4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F042C6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F042C6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F042C6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F042C6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F042F4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F042F4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F042F4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F042F4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F042F6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F042F6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F042F6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F042F6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F042G4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F042G4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F042G4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F042G4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F042G6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F042G6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F042G6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F042G6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F042K4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F042K4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F042K4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F042K4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F042K6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F042K6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F042K6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F042K6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F042T6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F042T6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F042T6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F042T6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F048C6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F048C6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F048C6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F048C6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F048G6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F048G6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F048G6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F048G6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F048T6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F048T6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F048T6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F048T6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F051C4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F051C4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F051C4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F051C4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F051C6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F051C6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F051C6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F051C6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F051C8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F051C8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F051C8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F051C8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F051K4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F051K4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F051K4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F051K4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F051K6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F051K6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F051K6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F051K6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F051K8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F051K8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F051K8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F051K8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F051R4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F051R4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F051R4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F051R4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F051R6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F051R6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F051R6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F051R6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F051R8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F051R8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F051R8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F051R8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F051T8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F051T8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F051T8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F051T8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F058C8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F058C8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F058C8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F058C8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F058R8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F058R8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F058R8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F058R8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F058T8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F058T8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F058T8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F058T8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F070C6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F070C6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F070C6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F070C6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F070CB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F070CB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F070CB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F070CB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F070F6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F070F6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F070F6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F070F6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F070RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F070RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F070RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F070RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F071C8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F071C8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F071C8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F071C8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F071CB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F071CB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F071CB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F071CB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F071RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F071RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F071RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F071RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F071V8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F071V8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F071V8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F071V8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F071VB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F071VB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F071VB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F071VB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F072C8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F072C8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F072C8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F072C8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F072CB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F072CB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F072CB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F072CB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F072R8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F072R8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F072R8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F072R8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F072RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F072RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F072RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F072RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F072V8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F072V8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F072V8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F072V8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F072VB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F072VB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F072VB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F072VB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F078CB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F078CB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F078CB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F078CB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F078RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F078RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F078RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F078RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F078VB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F078VB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F078VB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F078VB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F091CB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F091CB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F091CB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F091CB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F091CC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F091CC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F091CC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F091CC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F091RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F091RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F091RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F091RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F091RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F091RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F091RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F091RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F091VB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F091VB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F091VB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F091VB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F091VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F091VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F091VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F091VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F098CC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F098CC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F098CC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F098CC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F098RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F098RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F098RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F098RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F098VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F098VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F098VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F098VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F100C4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F100C4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F100C4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F100C4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F100C6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F100C6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F100C6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F100C6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F100C8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F100C8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F100C8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F100C8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F100CB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F100CB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F100CB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F100CB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F100R4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F100R4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F100R4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F100R4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F100R6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F100R6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F100R6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F100R6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F100R8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F100R8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F100R8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F100R8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F100RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F100RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F100RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F100RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F100RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F100RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F100RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F100RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x6000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F100RD = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F100RD.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F100RD",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F100RD",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x60000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F100RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F100RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F100RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F100RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F100V8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F100V8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F100V8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F100V8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F100VB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F100VB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F100VB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F100VB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F100VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F100VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F100VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F100VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x6000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F100VD = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F100VD.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F100VD",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F100VD",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x60000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F100VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F100VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F100VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F100VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F100ZC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F100ZC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F100ZC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F100ZC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x6000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F100ZD = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F100ZD.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F100ZD",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F100ZD",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x60000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F100ZE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F100ZE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F100ZE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F100ZE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F101C4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F101C4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F101C4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F101C4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F101C6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F101C6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F101C6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F101C6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F101C8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F101C8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F101C8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F101C8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F101CB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F101CB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F101CB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F101CB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F101R4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F101R4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F101R4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F101R4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F101R6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F101R6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F101R6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F101R6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F101R8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F101R8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F101R8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F101R8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F101RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F101RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F101RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F101RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F101RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F101RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F101RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F101RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F101RD = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F101RD.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F101RD",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F101RD",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x60000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F101RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F101RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F101RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F101RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F101RF = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F101RF.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F101RF",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F101RF",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F101RG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F101RG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F101RG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F101RG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F101T4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F101T4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F101T4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F101T4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F101T6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F101T6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F101T6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F101T6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F101T8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F101T8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F101T8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F101T8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F101TB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F101TB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F101TB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F101TB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F101V8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F101V8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F101V8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F101V8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F101VB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F101VB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F101VB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F101VB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F101VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F101VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F101VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F101VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F101VD = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F101VD.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F101VD",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F101VD",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x60000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F101VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F101VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F101VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F101VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F101VF = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F101VF.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F101VF",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F101VF",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F101VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F101VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F101VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F101VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F101ZC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F101ZC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F101ZC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F101ZC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F101ZD = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F101ZD.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F101ZD",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F101ZD",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x60000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F101ZE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F101ZE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F101ZE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F101ZE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F101ZF = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F101ZF.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F101ZF",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F101ZF",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F101ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F101ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F101ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F101ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F102C4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F102C4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F102C4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F102C4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F102C6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F102C6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F102C6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F102C6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F102C8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F102C8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F102C8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F102C8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F102CB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F102CB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F102CB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F102CB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F102R4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F102R4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F102R4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F102R4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F102R6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F102R6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F102R6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F102R6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F102R8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F102R8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F102R8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F102R8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F102RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F102RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F102RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F102RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F103C4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F103C4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F103C4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F103C4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32F103.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32F103C6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F103C6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F103C6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F103C6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32F103.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32F103C8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F103C8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F103C8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F103C8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32F103.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32F103CB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F103CB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F103CB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F103CB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32F103.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32F103R4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F103R4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F103R4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F103R4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32F103.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32F103R6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F103R6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F103R6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F103R6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32F103.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32F103R8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F103R8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F103R8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F103R8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32F103.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32F103RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F103RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F103RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F103RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32F103.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32F103RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F103RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F103RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F103RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32F103.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32F103RD = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F103RD.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F103RD",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F103RD",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x60000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32F103.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32F103RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F103RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F103RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F103RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32F103.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32F103RF = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F103RF.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F103RF",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F103RF",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32F103.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32F103RG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F103RG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F103RG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F103RG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32F103.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32F103T4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F103T4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F103T4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F103T4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32F103.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32F103T6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F103T6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F103T6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F103T6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32F103.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32F103T8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F103T8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F103T8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F103T8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32F103.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32F103TB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F103TB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F103TB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F103TB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32F103.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32F103V8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F103V8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F103V8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F103V8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32F103.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32F103VB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F103VB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F103VB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F103VB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32F103.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32F103VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F103VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F103VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F103VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32F103.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32F103VD = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F103VD.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F103VD",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F103VD",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x60000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32F103.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32F103VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F103VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F103VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F103VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32F103.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32F103VF = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F103VF.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F103VF",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F103VF",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32F103.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32F103VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F103VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F103VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F103VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32F103.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32F103ZC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F103ZC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F103ZC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F103ZC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32F103.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32F103ZD = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F103ZD.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F103ZD",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F103ZD",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x60000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32F103.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32F103ZE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F103ZE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F103ZE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F103ZE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32F103.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32F103ZF = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F103ZF.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F103ZF",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F103ZF",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32F103.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32F103ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F103ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F103ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F103ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32F103.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32F105R8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F105R8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F105R8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F105R8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F105RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F105RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F105RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F105RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F105RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F105RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F105RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F105RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F105V8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F105V8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F105V8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F105V8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F105VB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F105VB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F105VB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F105VB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F105VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F105VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F105VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F105VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F107RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F107RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F107RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F107RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F107RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F107RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F107RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F107RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F107VB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F107VB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F107VB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F107VB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F107VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F107VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F107VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F107VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F205RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F205RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F205RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F205RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F205RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F205RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F205RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F205RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F205RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F205RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F205RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F205RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F205RF = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F205RF.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F205RF",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F205RF",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0xC0000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F205RG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F205RG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F205RG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F205RG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F205VB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F205VB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F205VB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F205VB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F205VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F205VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F205VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F205VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F205VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F205VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F205VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F205VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F205VF = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F205VF.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F205VF",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F205VF",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0xC0000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F205VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F205VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F205VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F205VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F205ZC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F205ZC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F205ZC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F205ZC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F205ZE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F205ZE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F205ZE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F205ZE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F205ZF = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F205ZF.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F205ZF",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F205ZF",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0xC0000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F205ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F205ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F205ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F205ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F207IC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F207IC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F207IC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F207IC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F207IE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F207IE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F207IE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F207IE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F207IF = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F207IF.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F207IF",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F207IF",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0xC0000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F207IG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F207IG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F207IG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F207IG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F207VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F207VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F207VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F207VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F207VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F207VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F207VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F207VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F207VF = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F207VF.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F207VF",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F207VF",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0xC0000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F207VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F207VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F207VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F207VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F207ZC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F207ZC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F207ZC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F207ZC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F207ZE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F207ZE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F207ZE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F207ZE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F207ZF = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F207ZF.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F207ZF",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F207ZF",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0xC0000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F207ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F207ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F207ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F207ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F215RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F215RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F215RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F215RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F215RG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F215RG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F215RG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F215RG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F215VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F215VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F215VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F215VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F215VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F215VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F215VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F215VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F215ZE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F215ZE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F215ZE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F215ZE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F215ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F215ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F215ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F215ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F217IE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F217IE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F217IE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F217IE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F217IG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F217IG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F217IG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F217IG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F217VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F217VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F217VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F217VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F217VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F217VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F217VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F217VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F217ZE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F217ZE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F217ZE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F217ZE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F217ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F217ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32F217ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F217ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F301C6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F301C6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F301C6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F301C6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F301C8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F301C8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F301C8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F301C8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F301K6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F301K6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F301K6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F301K6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F301K8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F301K8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F301K8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F301K8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F301R6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F301R6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F301R6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F301R6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F301R8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F301R8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F301R8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F301R8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F302C6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F302C6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F302C6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F302C6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F302C8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F302C8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F302C8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F302C8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F302CB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F302CB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F302CB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F302CB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F302CC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F302CC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F302CC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F302CC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F302K6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F302K6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F302K6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F302K6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F302K8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F302K8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F302K8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F302K8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F302R6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F302R6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F302R6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F302R6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F302R8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F302R8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F302R8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F302R8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F302RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F302RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F302RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F302RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F302RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F302RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F302RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F302RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F302RD = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F302RD.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F302RD",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F302RD",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x60000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F302RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F302RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F302RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F302RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F302VB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F302VB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F302VB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F302VB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F302VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F302VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F302VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F302VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F302VD = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F302VD.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F302VD",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F302VD",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x60000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F302VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F302VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F302VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F302VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F302ZD = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F302ZD.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F302ZD",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F302ZD",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x60000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F302ZE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F302ZE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F302ZE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F302ZE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F303C6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F303C6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F303C6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F303C6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x1000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x3000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F303C8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F303C8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F303C8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F303C8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x1000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x3000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F303CB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F303CB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F303CB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F303CB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x2000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F303CC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F303CC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F303CC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F303CC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x2000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F303K6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F303K6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F303K6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F303K6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x1000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x3000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F303K8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F303K8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F303K8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F303K8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x1000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x3000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F303R6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F303R6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F303R6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F303R6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x1000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x3000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F303R8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F303R8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F303R8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F303R8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x1000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x3000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F303RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F303RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F303RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F303RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x2000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F303RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F303RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F303RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F303RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x2000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F303RD = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F303RD.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F303RD",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F303RD",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x60000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F303RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F303RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F303RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F303RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F303VB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F303VB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F303VB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F303VB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x2000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F303VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F303VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F303VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F303VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x2000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F303VD = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F303VD.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F303VD",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F303VD",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x60000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F303VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F303VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F303VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F303VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F303ZD = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F303ZD.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F303ZD",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F303ZD",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x60000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F303ZE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F303ZE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F303ZE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F303ZE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F318C8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F318C8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F318C8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F318C8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F318K8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F318K8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F318K8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F318K8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F328C8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F328C8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F328C8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F328C8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x1000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x3000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F334C4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F334C4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F334C4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F334C4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x1000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x3000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F334C6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F334C6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F334C6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F334C6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x1000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x3000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F334C8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F334C8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F334C8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F334C8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x1000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x3000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F334K4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F334K4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F334K4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F334K4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x1000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x3000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F334K6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F334K6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F334K6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F334K6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x1000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x3000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F334K8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F334K8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F334K8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F334K8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x1000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x3000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F334R6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F334R6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F334R6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F334R6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x1000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x3000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F334R8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F334R8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F334R8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F334R8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x1000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x3000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F358CC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F358CC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F358CC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F358CC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x2000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F358RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F358RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F358RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F358RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x2000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F358VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F358VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F358VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F358VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x2000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F373C8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F373C8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F373C8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F373C8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F373CB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F373CB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F373CB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F373CB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x6000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F373CC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F373CC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F373CC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F373CC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F373R8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F373R8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F373R8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F373R8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F373RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F373RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F373RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F373RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x6000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F373RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F373RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F373RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F373RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F373V8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F373V8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F373V8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F373V8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F373VB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F373VB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F373VB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F373VB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x6000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F373VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F373VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F373VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F373VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F378CC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F378CC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F378CC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F378CC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F378RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F378RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F378RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F378RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F378VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F378VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F378VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F378VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F398VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F398VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F398VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F398VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F401CB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F401CB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F401CB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F401CB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F401CC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F401CC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F401CC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F401CC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F401CD = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F401CD.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F401CD",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F401CD",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x60000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F401CE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F401CE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F401CE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F401CE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F401RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F401RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F401RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F401RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F401RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F401RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F401RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F401RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F401RD = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F401RD.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F401RD",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F401RD",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x60000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F401RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F401RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F401RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F401RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F401VB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F401VB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F401VB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F401VB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F401VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F401VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F401VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F401VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F401VD = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F401VD.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F401VD",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F401VD",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x60000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F401VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F401VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F401VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F401VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F405OE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F405OE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F405OE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F405OE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F405OG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F405OG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F405OG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F405OG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F405RG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F405RG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F405RG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F405RG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F405VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F405VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F405VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F405VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F405ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F405ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F405ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F405ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F407IE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F407IE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F407IE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F407IE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F407IG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F407IG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F407IG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F407IG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F407VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F407VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F407VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F407VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F407VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F407VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F407VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F407VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F407ZE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F407ZE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F407ZE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F407ZE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F407ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F407ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F407ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F407ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1C000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2001C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F410C8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F410C8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F410C8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F410C8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F410CB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F410CB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F410CB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F410CB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F410R8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F410R8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F410R8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F410R8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F410RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F410RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F410RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F410RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F410T8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F410T8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F410T8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F410T8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F410TB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F410TB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F410TB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F410TB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F411CC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F411CC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F411CC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F411CC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F411CE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F411CE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F411CE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F411CE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F411RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F411RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F411RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F411RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F411RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F411RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F411RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F411RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F411VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F411VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F411VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F411VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F411VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F411VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F411VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F411VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F412CE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F412CE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F412CE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F412CE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F412CG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F412CG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F412CG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F412CG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F412RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F412RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F412RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F412RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F412RG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F412RG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F412RG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F412RG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F412VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F412VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F412VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F412VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F412VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F412VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F412VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F412VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F412ZE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F412ZE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F412ZE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F412ZE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F412ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F412ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F412ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F412ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F413CG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F413CG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F413CG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F413CG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F413CH = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F413CH.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F413CH",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F413CH",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x180000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F413MG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F413MG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F413MG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F413MG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F413MH = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F413MH.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F413MH",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F413MH",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x180000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F413RG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F413RG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F413RG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F413RG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F413RH = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F413RH.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F413RH",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F413RH",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x180000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F413VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F413VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F413VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F413VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F413VH = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F413VH.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F413VH",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F413VH",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x180000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F413ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F413ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F413ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F413ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F413ZH = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F413ZH.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F413ZH",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F413ZH",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x180000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F415OG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F415OG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F415OG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F415OG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F415RG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F415RG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F415RG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F415RG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F415VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F415VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F415VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F415VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F415ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F415ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F415ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F415ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F417IE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F417IE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F417IE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F417IE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F417IG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F417IG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F417IG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F417IG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F417VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F417VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F417VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F417VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F417VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F417VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F417VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F417VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F417ZE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F417ZE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F417ZE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F417ZE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F417ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F417ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F417ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F417ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F423CH = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F423CH.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F423CH",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F423CH",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x180000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F423MH = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F423MH.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F423MH",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F423MH",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x180000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F423RH = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F423RH.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F423RH",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F423RH",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x180000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F423VH = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F423VH.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F423VH",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F423VH",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x180000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F423ZH = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F423ZH.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F423ZH",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F423ZH",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x180000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F427AG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F427AG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F427AG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F427AG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F427AI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F427AI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F427AI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F427AI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2_REGION_1", .tag = .flash, .offset = 0x8100000, .length = 0x10000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8110000, .length = 0xF0000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F427IG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F427IG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F427IG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F427IG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F427II = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F427II.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F427II",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F427II",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2_REGION_1", .tag = .flash, .offset = 0x8100000, .length = 0x10000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8110000, .length = 0xF0000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F427VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F427VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F427VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F427VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F427VI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F427VI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F427VI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F427VI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2_REGION_1", .tag = .flash, .offset = 0x8100000, .length = 0x10000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8110000, .length = 0xF0000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F427ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F427ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F427ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F427ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F427ZI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F427ZI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F427ZI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F427ZI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2_REGION_1", .tag = .flash, .offset = 0x8100000, .length = 0x10000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8110000, .length = 0xF0000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F429AG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F429AG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F429AG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F429AG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F429AI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F429AI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F429AI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F429AI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2_REGION_1", .tag = .flash, .offset = 0x8100000, .length = 0x10000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8110000, .length = 0xF0000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F429BE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F429BE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F429BE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F429BE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F429BG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F429BG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F429BG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F429BG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F429BI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F429BI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F429BI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F429BI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2_REGION_1", .tag = .flash, .offset = 0x8100000, .length = 0x10000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8110000, .length = 0xF0000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F429IE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F429IE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F429IE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F429IE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F429IG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F429IG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F429IG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F429IG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F429II = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F429II.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F429II",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F429II",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2_REGION_1", .tag = .flash, .offset = 0x8100000, .length = 0x10000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8110000, .length = 0xF0000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F429NE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F429NE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F429NE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F429NE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F429NG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F429NG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F429NG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F429NG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F429NI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F429NI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F429NI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F429NI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2_REGION_1", .tag = .flash, .offset = 0x8100000, .length = 0x10000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8110000, .length = 0xF0000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F429VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F429VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F429VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F429VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F429VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F429VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F429VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F429VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F429VI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F429VI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F429VI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F429VI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2_REGION_1", .tag = .flash, .offset = 0x8100000, .length = 0x10000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8110000, .length = 0xF0000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F429ZE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F429ZE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F429ZE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F429ZE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F429ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F429ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F429ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F429ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F429ZI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F429ZI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F429ZI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F429ZI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2_REGION_1", .tag = .flash, .offset = 0x8100000, .length = 0x10000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8110000, .length = 0xF0000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F437AI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F437AI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F437AI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F437AI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2_REGION_1", .tag = .flash, .offset = 0x8100000, .length = 0x10000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8110000, .length = 0xF0000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F437IG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F437IG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F437IG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F437IG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F437II = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F437II.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F437II",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F437II",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2_REGION_1", .tag = .flash, .offset = 0x8100000, .length = 0x10000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8110000, .length = 0xF0000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F437VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F437VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F437VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F437VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F437VI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F437VI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F437VI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F437VI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2_REGION_1", .tag = .flash, .offset = 0x8100000, .length = 0x10000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8110000, .length = 0xF0000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F437ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F437ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F437ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F437ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F437ZI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F437ZI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F437ZI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F437ZI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2_REGION_1", .tag = .flash, .offset = 0x8100000, .length = 0x10000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8110000, .length = 0xF0000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F439AI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F439AI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F439AI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F439AI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2_REGION_1", .tag = .flash, .offset = 0x8100000, .length = 0x10000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8110000, .length = 0xF0000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F439BG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F439BG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F439BG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F439BG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F439BI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F439BI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F439BI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F439BI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2_REGION_1", .tag = .flash, .offset = 0x8100000, .length = 0x10000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8110000, .length = 0xF0000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F439IG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F439IG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F439IG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F439IG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F439II = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F439II.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F439II",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F439II",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2_REGION_1", .tag = .flash, .offset = 0x8100000, .length = 0x10000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8110000, .length = 0xF0000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F439NG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F439NG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F439NG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F439NG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F439NI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F439NI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F439NI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F439NI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2_REGION_1", .tag = .flash, .offset = 0x8100000, .length = 0x10000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8110000, .length = 0xF0000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F439VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F439VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F439VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F439VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F439VI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F439VI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F439VI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F439VI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2_REGION_1", .tag = .flash, .offset = 0x8100000, .length = 0x10000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8110000, .length = 0xF0000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F439ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F439ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F439ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F439ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F439ZI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F439ZI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F439ZI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F439ZI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2_REGION_1", .tag = .flash, .offset = 0x8100000, .length = 0x10000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8110000, .length = 0xF0000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F446MC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F446MC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F446MC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F446MC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F446ME = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F446ME.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F446ME",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F446ME",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F446RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F446RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F446RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F446RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F446RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F446RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F446RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F446RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F446VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F446VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F446VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F446VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F446VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F446VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F446VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F446VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F446ZC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F446ZC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F446ZC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F446ZC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F446ZE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F446ZE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F446ZE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F446ZE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F469AE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F469AE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F469AE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F469AE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F469AG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F469AG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F469AG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F469AG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F469AI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F469AI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F469AI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F469AI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2_REGION_1", .tag = .flash, .offset = 0x8100000, .length = 0x10000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8110000, .length = 0xF0000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F469BE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F469BE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F469BE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F469BE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F469BG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F469BG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F469BG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F469BG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F469BI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F469BI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F469BI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F469BI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2_REGION_1", .tag = .flash, .offset = 0x8100000, .length = 0x10000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8110000, .length = 0xF0000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F469IE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F469IE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F469IE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F469IE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F469IG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F469IG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F469IG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F469IG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F469II = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F469II.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F469II",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F469II",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2_REGION_1", .tag = .flash, .offset = 0x8100000, .length = 0x10000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8110000, .length = 0xF0000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F469NE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F469NE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F469NE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F469NE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F469NG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F469NG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F469NG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F469NG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F469NI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F469NI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F469NI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F469NI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2_REGION_1", .tag = .flash, .offset = 0x8100000, .length = 0x10000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8110000, .length = 0xF0000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F469VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F469VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F469VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F469VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F469VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F469VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F469VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F469VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F469VI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F469VI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F469VI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F469VI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2_REGION_1", .tag = .flash, .offset = 0x8100000, .length = 0x10000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8110000, .length = 0xF0000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F469ZE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F469ZE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F469ZE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F469ZE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F469ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F469ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F469ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F469ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F469ZI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F469ZI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F469ZI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F469ZI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2_REGION_1", .tag = .flash, .offset = 0x8100000, .length = 0x10000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8110000, .length = 0xF0000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F479AG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F479AG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F479AG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F479AG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F479AI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F479AI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F479AI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F479AI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2_REGION_1", .tag = .flash, .offset = 0x8100000, .length = 0x10000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8110000, .length = 0xF0000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F479BG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F479BG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F479BG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F479BG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F479BI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F479BI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F479BI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F479BI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2_REGION_1", .tag = .flash, .offset = 0x8100000, .length = 0x10000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8110000, .length = 0xF0000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F479IG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F479IG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F479IG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F479IG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F479II = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F479II.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F479II",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F479II",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2_REGION_1", .tag = .flash, .offset = 0x8100000, .length = 0x10000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8110000, .length = 0xF0000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F479NG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F479NG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F479NG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F479NG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F479NI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F479NI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F479NI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F479NI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2_REGION_1", .tag = .flash, .offset = 0x8100000, .length = 0x10000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8110000, .length = 0xF0000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F479VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F479VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F479VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F479VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F479VI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F479VI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F479VI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F479VI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2_REGION_1", .tag = .flash, .offset = 0x8100000, .length = 0x10000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8110000, .length = 0xF0000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F479ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F479ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F479ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F479ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F479ZI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F479ZI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F479ZI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F479ZI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2_REGION_1", .tag = .flash, .offset = 0x8100000, .length = 0x10000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8110000, .length = 0xF0000, .access = .rx },
                .{ .name = "CCMRAM", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F722IC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F722IC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F722IC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F722IC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F722IE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F722IE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F722IE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F722IE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F722RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F722RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F722RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F722RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F722RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F722RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F722RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F722RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F722VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F722VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F722VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F722VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F722VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F722VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F722VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F722VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F722ZC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F722ZC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F722ZC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F722ZC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F722ZE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F722ZE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F722ZE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F722ZE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F723IC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F723IC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F723IC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F723IC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F723IE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F723IE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F723IE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F723IE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F723VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F723VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F723VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F723VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F723VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F723VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F723VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F723VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F723ZC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F723ZC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F723ZC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F723ZC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F723ZE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F723ZE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F723ZE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F723ZE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F730I8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F730I8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F730I8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F730I8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F730R8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F730R8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F730R8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F730R8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F730V8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F730V8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F730V8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F730V8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F730Z8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F730Z8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F730Z8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F730Z8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F732IE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F732IE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F732IE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F732IE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F732RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F732RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F732RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F732RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F732VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F732VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F732VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F732VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F732ZE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F732ZE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F732ZE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F732ZE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F733IE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F733IE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F733IE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F733IE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F733VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F733VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F733VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F733VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F733ZE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F733ZE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F733ZE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F733ZE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x30000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F745IE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F745IE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F745IE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F745IE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F745IG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F745IG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F745IG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F745IG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F745VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F745VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F745VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F745VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F745VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F745VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F745VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F745VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F745ZE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F745ZE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F745ZE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F745ZE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F745ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F745ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F745ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F745ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F746BE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F746BE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F746BE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F746BE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F746BG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F746BG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F746BG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F746BG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F746IE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F746IE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F746IE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F746IE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F746IG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F746IG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F746IG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F746IG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F746NE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F746NE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F746NE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F746NE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F746NG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F746NG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F746NG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F746NG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F746VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F746VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F746VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F746VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F746VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F746VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F746VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F746VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F746ZE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F746ZE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F746ZE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F746ZE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F746ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F746ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F746ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F746ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F750N8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F750N8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F750N8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F750N8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F750V8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F750V8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F750V8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F750V8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F750Z8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F750Z8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F750Z8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F750Z8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F756BG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F756BG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F756BG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F756BG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F756IG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F756IG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F756IG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F756IG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F756NG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F756NG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F756NG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F756NG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F756VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F756VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F756VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F756VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F756ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F756ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F756ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F756ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20010000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F765BG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F765BG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F765BG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F765BG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F765BI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F765BI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F765BI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F765BI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F765IG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F765IG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F765IG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F765IG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F765II = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F765II.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F765II",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F765II",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F765NG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F765NG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F765NG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F765NG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F765NI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F765NI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F765NI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F765NI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F765VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F765VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F765VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F765VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F765VI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F765VI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F765VI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F765VI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F765ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F765ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F765ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F765ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F765ZI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F765ZI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F765ZI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F765ZI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F767BG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F767BG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F767BG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F767BG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F767BI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F767BI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F767BI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F767BI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F767IG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F767IG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F767IG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F767IG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F767II = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F767II.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F767II",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F767II",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F767NG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F767NG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F767NG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F767NG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F767NI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F767NI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F767NI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F767NI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F767VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F767VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F767VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F767VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F767VI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F767VI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F767VI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F767VI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F767ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F767ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F767ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F767ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F767ZI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F767ZI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F767ZI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F767ZI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F768AI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F768AI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F768AI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F768AI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F769AG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F769AG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F769AG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F769AG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F769AI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F769AI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F769AI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F769AI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F769BG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F769BG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F769BG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F769BG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F769BI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F769BI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F769BI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F769BI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F769IG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F769IG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F769IG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F769IG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F769II = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F769II.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F769II",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F769II",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F769NG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F769NG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F769NG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F769NG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F769NI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F769NI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F769NI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F769NI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F777BI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F777BI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F777BI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F777BI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F777II = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F777II.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F777II",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F777II",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F777NI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F777NI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F777NI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F777NI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F777VI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F777VI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F777VI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F777VI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F777ZI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F777ZI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F777ZI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F777ZI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F778AI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F778AI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F778AI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F778AI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F779AI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F779AI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F779AI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F779AI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F779BI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F779BI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F779BI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F779BI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F779II = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F779II.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F779II",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F779II",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32F779NI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32F779NI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32F779NI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32F779NI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20020000, .length = 0x60000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G030C6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G030C6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G030C6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G030C6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G030C8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G030C8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G030C8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G030C8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G030F6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G030F6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G030F6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G030F6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G030J6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G030J6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G030J6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G030J6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G030K6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G030K6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G030K6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G030K6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G030K8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G030K8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G030K8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G030K8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G031C4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G031C4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G031C4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G031C4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G031C6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G031C6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G031C6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G031C6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G031C8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G031C8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G031C8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G031C8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G031F4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G031F4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G031F4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G031F4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G031F6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G031F6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G031F6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G031F6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G031F8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G031F8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G031F8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G031F8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G031G4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G031G4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G031G4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G031G4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G031G6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G031G6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G031G6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G031G6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G031G8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G031G8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G031G8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G031G8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G031J4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G031J4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G031J4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G031J4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G031J6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G031J6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G031J6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G031J6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G031K4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G031K4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G031K4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G031K4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G031K6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G031K6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G031K6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G031K6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G031K8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G031K8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G031K8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G031K8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G031Y8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G031Y8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G031Y8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G031Y8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G041C6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G041C6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G041C6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G041C6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G041C8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G041C8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G041C8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G041C8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G041F6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G041F6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G041F6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G041F6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G041F8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G041F8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G041F8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G041F8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G041G6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G041G6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G041G6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G041G6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G041G8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G041G8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G041G8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G041G8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G041J6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G041J6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G041J6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G041J6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G041K6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G041K6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G041K6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G041K6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G041K8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G041K8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G041K8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G041K8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G041Y8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G041Y8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G041Y8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G041Y8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G050C6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G050C6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G050C6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G050C6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G050C8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G050C8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G050C8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G050C8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G050F6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G050F6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G050F6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G050F6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G050K6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G050K6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G050K6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G050K6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G050K8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G050K8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G050K8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G050K8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G051C6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G051C6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G051C6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G051C6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G051C8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G051C8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G051C8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G051C8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G051F6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G051F6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G051F6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G051F6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G051F8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G051F8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G051F8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G051F8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G051G6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G051G6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G051G6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G051G6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G051G8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G051G8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G051G8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G051G8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G051K6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G051K6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G051K6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G051K6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G051K8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G051K8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G051K8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G051K8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G061C6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G061C6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G061C6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G061C6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G061C8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G061C8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G061C8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G061C8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G061F6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G061F6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G061F6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G061F6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G061F8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G061F8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G061F8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G061F8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G061G6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G061G6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G061G6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G061G6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G061G8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G061G8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G061G8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G061G8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G061K6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G061K6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G061K6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G061K6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G061K8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G061K8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G061K8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G061K8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G070CB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G070CB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G070CB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G070CB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x9000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G070KB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G070KB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G070KB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G070KB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x9000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G070RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G070RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G070RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G070RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x9000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G071C6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G071C6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G071C6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G071C6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x9000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G071C8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G071C8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G071C8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G071C8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x9000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G071CB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G071CB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G071CB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G071CB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x9000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G071EB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G071EB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G071EB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G071EB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x9000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G071G6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G071G6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G071G6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G071G6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x9000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G071G8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G071G8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G071G8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G071G8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x9000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G071GB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G071GB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G071GB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G071GB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x9000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G071K6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G071K6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G071K6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G071K6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x9000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G071K8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G071K8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G071K8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G071K8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x9000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G071KB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G071KB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G071KB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G071KB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x9000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G071R6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G071R6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G071R6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G071R6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x9000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G071R8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G071R8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G071R8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G071R8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x9000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G071RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G071RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G071RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G071RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x9000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G081CB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G081CB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G081CB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G081CB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x9000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G081EB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G081EB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G081EB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G081EB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x9000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G081GB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G081GB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G081GB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G081GB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x9000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G081KB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G081KB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G081KB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G081KB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x9000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G081RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G081RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G081RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G081RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x9000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G0B0CE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G0B0CE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G0B0CE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G0B0CE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x24000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G0B0KE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G0B0KE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G0B0KE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G0B0KE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x24000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G0B0RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G0B0RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G0B0RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G0B0RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x24000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G0B0VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G0B0VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G0B0VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G0B0VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x24000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G0B1CB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G0B1CB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G0B1CB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G0B1CB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x24000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G0B1CC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G0B1CC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G0B1CC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G0B1CC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x24000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G0B1CE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G0B1CE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G0B1CE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G0B1CE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x24000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G0B1KB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G0B1KB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G0B1KB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G0B1KB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x24000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G0B1KC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G0B1KC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G0B1KC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G0B1KC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x24000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G0B1KE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G0B1KE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G0B1KE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G0B1KE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x24000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G0B1MB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G0B1MB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G0B1MB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G0B1MB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x24000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G0B1MC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G0B1MC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G0B1MC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G0B1MC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x24000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G0B1ME = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G0B1ME.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G0B1ME",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G0B1ME",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x24000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G0B1NE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G0B1NE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G0B1NE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G0B1NE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x24000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G0B1RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G0B1RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G0B1RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G0B1RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x24000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G0B1RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G0B1RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G0B1RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G0B1RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x24000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G0B1RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G0B1RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G0B1RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G0B1RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x24000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G0B1VB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G0B1VB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G0B1VB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G0B1VB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x24000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G0B1VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G0B1VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G0B1VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G0B1VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x24000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G0B1VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G0B1VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G0B1VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G0B1VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x24000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G0C1CC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G0C1CC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G0C1CC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G0C1CC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x24000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G0C1CE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G0C1CE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G0C1CE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G0C1CE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x24000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G0C1KC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G0C1KC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G0C1KC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G0C1KC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x24000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G0C1KE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G0C1KE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G0C1KE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G0C1KE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x24000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G0C1MC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G0C1MC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G0C1MC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G0C1MC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x24000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G0C1ME = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G0C1ME.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G0C1ME",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G0C1ME",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x24000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G0C1NE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G0C1NE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G0C1NE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G0C1NE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x24000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G0C1RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G0C1RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G0C1RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G0C1RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x24000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G0C1RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G0C1RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G0C1RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G0C1RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x24000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G0C1VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G0C1VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G0C1VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G0C1VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x24000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G0C1VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G0C1VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32G0C1VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G0C1VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x24000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32G431C6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G431C6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G431C6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G431C6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x2800, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20004000, .length = 0x1800, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20005800, .length = 0x2800, .access = .rwx },
            },
        },
    };

    ret.STM32G431C8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G431C8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G431C8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G431C8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x2800, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20004000, .length = 0x1800, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20005800, .length = 0x2800, .access = .rwx },
            },
        },
    };

    ret.STM32G431CB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G431CB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G431CB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G431CB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x2800, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20004000, .length = 0x1800, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20005800, .length = 0x2800, .access = .rwx },
            },
        },
    };

    ret.STM32G431K6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G431K6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G431K6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G431K6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x2800, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20004000, .length = 0x1800, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20005800, .length = 0x2800, .access = .rwx },
            },
        },
    };

    ret.STM32G431K8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G431K8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G431K8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G431K8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x2800, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20004000, .length = 0x1800, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20005800, .length = 0x2800, .access = .rwx },
            },
        },
    };

    ret.STM32G431KB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G431KB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G431KB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G431KB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x2800, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20004000, .length = 0x1800, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20005800, .length = 0x2800, .access = .rwx },
            },
        },
    };

    ret.STM32G431M6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G431M6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G431M6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G431M6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x2800, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20004000, .length = 0x1800, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20005800, .length = 0x2800, .access = .rwx },
            },
        },
    };

    ret.STM32G431M8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G431M8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G431M8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G431M8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x2800, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20004000, .length = 0x1800, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20005800, .length = 0x2800, .access = .rwx },
            },
        },
    };

    ret.STM32G431MB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G431MB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G431MB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G431MB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x2800, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20004000, .length = 0x1800, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20005800, .length = 0x2800, .access = .rwx },
            },
        },
    };

    ret.STM32G431R6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G431R6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G431R6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G431R6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x2800, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20004000, .length = 0x1800, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20005800, .length = 0x2800, .access = .rwx },
            },
        },
    };

    ret.STM32G431R8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G431R8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G431R8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G431R8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x2800, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20004000, .length = 0x1800, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20005800, .length = 0x2800, .access = .rwx },
            },
        },
    };

    ret.STM32G431RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G431RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G431RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G431RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x2800, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20004000, .length = 0x1800, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20005800, .length = 0x2800, .access = .rwx },
            },
        },
    };

    ret.STM32G431V6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G431V6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G431V6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G431V6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x2800, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20004000, .length = 0x1800, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20005800, .length = 0x2800, .access = .rwx },
            },
        },
    };

    ret.STM32G431V8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G431V8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G431V8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G431V8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x2800, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20004000, .length = 0x1800, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20005800, .length = 0x2800, .access = .rwx },
            },
        },
    };

    ret.STM32G431VB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G431VB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G431VB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G431VB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x2800, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20004000, .length = 0x1800, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20005800, .length = 0x2800, .access = .rwx },
            },
        },
    };

    ret.STM32G441CB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G441CB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G441CB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G441CB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x2800, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20004000, .length = 0x1800, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20005800, .length = 0x2800, .access = .rwx },
            },
        },
    };

    ret.STM32G441KB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G441KB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G441KB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G441KB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x2800, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20004000, .length = 0x1800, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20005800, .length = 0x2800, .access = .rwx },
            },
        },
    };

    ret.STM32G441MB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G441MB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G441MB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G441MB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x2800, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20004000, .length = 0x1800, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20005800, .length = 0x2800, .access = .rwx },
            },
        },
    };

    ret.STM32G441RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G441RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G441RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G441RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x2800, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20004000, .length = 0x1800, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20005800, .length = 0x2800, .access = .rwx },
            },
        },
    };

    ret.STM32G441VB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G441VB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G441VB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G441VB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x2800, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20004000, .length = 0x1800, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20005800, .length = 0x2800, .access = .rwx },
            },
        },
    };

    ret.STM32G471CC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G471CC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G471CC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G471CC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G471CE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G471CE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G471CE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G471CE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G471MC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G471MC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G471MC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G471MC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G471ME = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G471ME.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G471ME",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G471ME",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G471QC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G471QC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G471QC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G471QC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G471QE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G471QE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G471QE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G471QE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G471RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G471RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G471RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G471RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G471RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G471RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G471RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G471RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G471VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G471VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G471VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G471VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G471VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G471VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G471VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G471VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G473CB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G473CB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G473CB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G473CB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G473CC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G473CC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G473CC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G473CC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G473CE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G473CE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G473CE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G473CE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G473MB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G473MB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G473MB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G473MB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G473MC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G473MC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G473MC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G473MC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G473ME = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G473ME.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G473ME",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G473ME",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G473PB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G473PB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G473PB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G473PB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G473PC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G473PC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G473PC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G473PC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G473PE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G473PE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G473PE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G473PE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G473QB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G473QB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G473QB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G473QB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G473QC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G473QC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G473QC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G473QC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G473QE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G473QE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G473QE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G473QE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G473RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G473RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G473RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G473RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G473RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G473RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G473RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G473RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G473RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G473RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G473RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G473RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G473VB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G473VB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G473VB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G473VB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G473VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G473VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G473VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G473VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G473VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G473VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G473VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G473VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G474CB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G474CB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G474CB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G474CB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G474CC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G474CC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G474CC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G474CC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G474CE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G474CE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G474CE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G474CE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G474MB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G474MB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G474MB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G474MB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G474MC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G474MC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G474MC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G474MC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G474ME = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G474ME.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G474ME",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G474ME",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G474PB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G474PB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G474PB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G474PB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G474PC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G474PC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G474PC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G474PC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G474PE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G474PE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G474PE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G474PE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G474QB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G474QB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G474QB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G474QB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G474QC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G474QC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G474QC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G474QC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G474QE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G474QE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G474QE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G474QE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G474RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G474RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G474RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G474RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G474RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G474RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G474RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G474RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G474RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G474RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G474RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G474RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G474VB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G474VB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G474VB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G474VB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G474VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G474VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G474VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G474VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G474VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G474VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G474VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G474VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G483CE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G483CE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G483CE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G483CE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G483ME = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G483ME.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G483ME",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G483ME",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G483PE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G483PE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G483PE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G483PE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G483QE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G483QE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G483QE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G483QE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G483RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G483RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G483RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G483RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G483VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G483VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G483VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G483VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G484CE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G484CE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G484CE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G484CE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G484ME = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G484ME.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G484ME",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G484ME",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G484PE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G484PE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G484PE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G484PE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G484QE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G484QE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G484QE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G484QE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G484RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G484RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G484RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G484RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G484VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G484VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G484VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G484VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32G491CC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G491CC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G491CC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G491CC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32G491CE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G491CE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G491CE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G491CE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32G491KC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G491KC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G491KC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G491KC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32G491KE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G491KE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G491KE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G491KE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32G491MC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G491MC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G491MC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G491MC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32G491ME = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G491ME.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G491ME",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G491ME",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32G491RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G491RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G491RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G491RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32G491RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G491RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G491RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G491RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32G491VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G491VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G491VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G491VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32G491VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G491VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G491VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G491VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32G4A1CE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G4A1CE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G4A1CE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G4A1CE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32G4A1KE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G4A1KE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G4A1KE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G4A1KE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32G4A1ME = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G4A1ME.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G4A1ME",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G4A1ME",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32G4A1RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G4A1RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G4A1RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G4A1RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32G4A1VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32G4A1VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32G4A1VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32G4A1VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "CCMRAM_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20014000, .length = 0x4000, .access = .rwx },
                .{ .name = "CCMRAM_DCODE", .tag = .ram, .offset = 0x20018000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H503CB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H503CB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H503CB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H503CB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8010000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20004000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H503EB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H503EB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H503EB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H503EB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8010000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20004000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H503KB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H503KB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H503KB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H503KB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8010000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20004000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H503RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H503RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H503RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H503RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8010000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20004000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H523CC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H523CC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H523CC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H523CC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8020000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20020000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20034000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H523CE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H523CE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H523CE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H523CE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20020000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20034000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H523HE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H523HE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H523HE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H523HE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20020000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20034000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H523RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H523RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H523RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H523RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8020000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20020000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20034000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H523RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H523RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H523RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H523RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20020000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20034000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H523VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H523VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H523VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H523VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8020000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20020000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20034000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H523VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H523VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H523VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H523VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20020000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20034000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H523ZC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H523ZC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H523ZC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H523ZC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8020000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20020000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20034000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H523ZE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H523ZE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H523ZE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H523ZE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20020000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20034000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H533CE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H533CE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H533CE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H533CE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20020000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20034000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H533HE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H533HE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H533HE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H533HE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20020000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20034000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H533RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H533RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H533RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H533RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20020000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20034000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H533VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H533VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H533VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H533VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20020000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20034000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H533ZE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H533ZE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H533ZE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H533ZE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20020000, .length = 0x14000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20034000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H562AG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H562AG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H562AG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H562AG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20050000, .length = 0x50000, .access = .rwx },
            },
        },
    };

    ret.STM32H562AI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H562AI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H562AI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H562AI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20050000, .length = 0x50000, .access = .rwx },
            },
        },
    };

    ret.STM32H562IG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H562IG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H562IG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H562IG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20050000, .length = 0x50000, .access = .rwx },
            },
        },
    };

    ret.STM32H562II = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H562II.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H562II",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H562II",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20050000, .length = 0x50000, .access = .rwx },
            },
        },
    };

    ret.STM32H562RG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H562RG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H562RG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H562RG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20050000, .length = 0x50000, .access = .rwx },
            },
        },
    };

    ret.STM32H562RI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H562RI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H562RI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H562RI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20050000, .length = 0x50000, .access = .rwx },
            },
        },
    };

    ret.STM32H562VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H562VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H562VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H562VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20050000, .length = 0x50000, .access = .rwx },
            },
        },
    };

    ret.STM32H562VI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H562VI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H562VI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H562VI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20050000, .length = 0x50000, .access = .rwx },
            },
        },
    };

    ret.STM32H562ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H562ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H562ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H562ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20050000, .length = 0x50000, .access = .rwx },
            },
        },
    };

    ret.STM32H562ZI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H562ZI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H562ZI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H562ZI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20050000, .length = 0x50000, .access = .rwx },
            },
        },
    };

    ret.STM32H563AG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H563AG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H563AG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H563AG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20050000, .length = 0x50000, .access = .rwx },
            },
        },
    };

    ret.STM32H563AI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H563AI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H563AI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H563AI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20050000, .length = 0x50000, .access = .rwx },
            },
        },
    };

    ret.STM32H563IG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H563IG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H563IG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H563IG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20050000, .length = 0x50000, .access = .rwx },
            },
        },
    };

    ret.STM32H563II = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H563II.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H563II",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H563II",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20050000, .length = 0x50000, .access = .rwx },
            },
        },
    };

    ret.STM32H563MI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H563MI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H563MI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H563MI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20050000, .length = 0x50000, .access = .rwx },
            },
        },
    };

    ret.STM32H563RG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H563RG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H563RG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H563RG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20050000, .length = 0x50000, .access = .rwx },
            },
        },
    };

    ret.STM32H563RI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H563RI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H563RI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H563RI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20050000, .length = 0x50000, .access = .rwx },
            },
        },
    };

    ret.STM32H563VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H563VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H563VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H563VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20050000, .length = 0x50000, .access = .rwx },
            },
        },
    };

    ret.STM32H563VI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H563VI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H563VI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H563VI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20050000, .length = 0x50000, .access = .rwx },
            },
        },
    };

    ret.STM32H563ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H563ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H563ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H563ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20050000, .length = 0x50000, .access = .rwx },
            },
        },
    };

    ret.STM32H563ZI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H563ZI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H563ZI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H563ZI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20050000, .length = 0x50000, .access = .rwx },
            },
        },
    };

    ret.STM32H573AI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H573AI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H573AI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H573AI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20050000, .length = 0x50000, .access = .rwx },
            },
        },
    };

    ret.STM32H573II = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H573II.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H573II",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H573II",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20050000, .length = 0x50000, .access = .rwx },
            },
        },
    };

    ret.STM32H573MI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H573MI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H573MI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H573MI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20050000, .length = 0x50000, .access = .rwx },
            },
        },
    };

    ret.STM32H573RI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H573RI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H573RI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H573RI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20050000, .length = 0x50000, .access = .rwx },
            },
        },
    };

    ret.STM32H573VI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H573VI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H573VI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H573VI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20050000, .length = 0x50000, .access = .rwx },
            },
        },
    };

    ret.STM32H573ZI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H573ZI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H573ZI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H573ZI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20050000, .length = 0x50000, .access = .rwx },
            },
        },
    };

    ret.STM32H723VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H723VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H723VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H723VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x50000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x8000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H723VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H723VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H723VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H723VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x50000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x8000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H723ZE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H723ZE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H723ZE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H723ZE",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x50000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x8000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H723ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H723ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H723ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H723ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x50000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x8000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H725AE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H725AE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H725AE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H725AE",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x50000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x8000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H725AG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H725AG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H725AG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H725AG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x50000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x8000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H725IE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H725IE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H725IE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H725IE",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x50000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x8000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H725IG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H725IG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H725IG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H725IG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x50000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x8000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H725RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H725RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H725RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H725RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x50000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x8000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H725RG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H725RG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H725RG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H725RG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x50000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x8000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H725VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H725VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H725VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H725VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x50000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x8000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H725VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H725VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H725VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H725VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x50000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x8000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H725ZE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H725ZE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H725ZE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H725ZE",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x50000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x8000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H725ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H725ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H725ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H725ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x50000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x8000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H730AB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H730AB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H730AB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H730AB",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x50000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x8000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H730IB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H730IB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H730IB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H730IB",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x50000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x8000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H730VB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H730VB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H730VB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H730VB",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x50000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x8000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H730ZB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H730ZB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H730ZB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H730ZB",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x50000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x8000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H733VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H733VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H733VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H733VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x50000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x8000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H733ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H733ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H733ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H733ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x50000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x8000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H735AG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H735AG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H735AG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H735AG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x50000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x8000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H735IG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H735IG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H735IG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H735IG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x50000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x8000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H735RG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H735RG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H735RG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H735RG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x50000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x8000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H735VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H735VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H735VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H735VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x50000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x8000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H735ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H735ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H735ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H735ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x50000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x8000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H742AG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H742AG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H742AG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H742AG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x60000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x8000, .access = .rwx },
                .{ .name = "RAM2_D2", .tag = .ram, .offset = 0x30020000, .length = 0x4000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H742AI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H742AI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H742AI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H742AI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x60000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x8000, .access = .rwx },
                .{ .name = "RAM2_D2", .tag = .ram, .offset = 0x30020000, .length = 0x4000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H742BG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H742BG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H742BG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H742BG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x60000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x8000, .access = .rwx },
                .{ .name = "RAM2_D2", .tag = .ram, .offset = 0x30020000, .length = 0x4000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H742BI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H742BI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H742BI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H742BI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x60000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x8000, .access = .rwx },
                .{ .name = "RAM2_D2", .tag = .ram, .offset = 0x30020000, .length = 0x4000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H742IG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H742IG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H742IG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H742IG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x60000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x8000, .access = .rwx },
                .{ .name = "RAM2_D2", .tag = .ram, .offset = 0x30020000, .length = 0x4000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H742II = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H742II.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H742II",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H742II",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x60000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x8000, .access = .rwx },
                .{ .name = "RAM2_D2", .tag = .ram, .offset = 0x30020000, .length = 0x4000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H742VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H742VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H742VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H742VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x60000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x8000, .access = .rwx },
                .{ .name = "RAM2_D2", .tag = .ram, .offset = 0x30020000, .length = 0x4000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H742VI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H742VI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H742VI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H742VI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x60000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x8000, .access = .rwx },
                .{ .name = "RAM2_D2", .tag = .ram, .offset = 0x30020000, .length = 0x4000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H742XG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H742XG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H742XG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H742XG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x60000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x8000, .access = .rwx },
                .{ .name = "RAM2_D2", .tag = .ram, .offset = 0x30020000, .length = 0x4000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H742XI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H742XI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H742XI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H742XI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x60000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x8000, .access = .rwx },
                .{ .name = "RAM2_D2", .tag = .ram, .offset = 0x30020000, .length = 0x4000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H742ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H742ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H742ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H742ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x60000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x8000, .access = .rwx },
                .{ .name = "RAM2_D2", .tag = .ram, .offset = 0x30020000, .length = 0x4000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H742ZI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H742ZI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H742ZI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H742ZI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x60000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x8000, .access = .rwx },
                .{ .name = "RAM2_D2", .tag = .ram, .offset = 0x30020000, .length = 0x4000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H743AG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H743AG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H743AG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H743AG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H743AI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H743AI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H743AI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H743AI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H743BG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H743BG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H743BG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H743BG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H743BI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H743BI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H743BI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H743BI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H743IG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H743IG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H743IG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H743IG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H743II = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H743II.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H743II",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H743II",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H743VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H743VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H743VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H743VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H743VI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H743VI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H743VI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H743VI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H743XG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H743XG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H743XG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H743XG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H743XI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H743XI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H743XI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H743XI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H743ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H743ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H743ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H743ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H743ZI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H743ZI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H743ZI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H743ZI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H745BG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H745BG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H745BG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H745BG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x10000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x18000000, .length = 0x10000, .access = .rwx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
            },
        },
    };

    ret.STM32H745BI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H745BI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H745BI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H745BI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x10000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x18000000, .length = 0x10000, .access = .rwx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
            },
        },
    };

    ret.STM32H745IG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H745IG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H745IG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H745IG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x10000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x18000000, .length = 0x10000, .access = .rwx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
            },
        },
    };

    ret.STM32H745II = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H745II.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H745II",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H745II",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x10000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x18000000, .length = 0x10000, .access = .rwx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
            },
        },
    };

    ret.STM32H745XG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H745XG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H745XG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H745XG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x10000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x18000000, .length = 0x10000, .access = .rwx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
            },
        },
    };

    ret.STM32H745XI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H745XI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H745XI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H745XI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x10000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x18000000, .length = 0x10000, .access = .rwx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
            },
        },
    };

    ret.STM32H745ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H745ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H745ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H745ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x10000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x18000000, .length = 0x10000, .access = .rwx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
            },
        },
    };

    ret.STM32H745ZI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H745ZI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H745ZI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H745ZI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x10000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x18000000, .length = 0x10000, .access = .rwx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
            },
        },
    };

    ret.STM32H747AG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H747AG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H747AG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H747AG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x10000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x18000000, .length = 0x10000, .access = .rwx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
            },
        },
    };

    ret.STM32H747AI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H747AI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H747AI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H747AI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x10000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x18000000, .length = 0x10000, .access = .rwx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
            },
        },
    };

    ret.STM32H747BG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H747BG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H747BG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H747BG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x10000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x18000000, .length = 0x10000, .access = .rwx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
            },
        },
    };

    ret.STM32H747BI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H747BI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H747BI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H747BI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x10000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x18000000, .length = 0x10000, .access = .rwx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
            },
        },
    };

    ret.STM32H747IG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H747IG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H747IG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H747IG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x10000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x18000000, .length = 0x10000, .access = .rwx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
            },
        },
    };

    ret.STM32H747II = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H747II.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H747II",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H747II",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x10000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x18000000, .length = 0x10000, .access = .rwx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
            },
        },
    };

    ret.STM32H747XG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H747XG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H747XG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H747XG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x10000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x18000000, .length = 0x10000, .access = .rwx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
            },
        },
    };

    ret.STM32H747XI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H747XI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H747XI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H747XI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x10000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x18000000, .length = 0x10000, .access = .rwx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
            },
        },
    };

    ret.STM32H747ZI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H747ZI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H747ZI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H747ZI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x10000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x18000000, .length = 0x10000, .access = .rwx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
            },
        },
    };

    ret.STM32H750IB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H750IB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H750IB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H750IB",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H750VB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H750VB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H750VB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H750VB",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H750XB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H750XB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H750XB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H750XB",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H750ZB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H750ZB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H750ZB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H750ZB",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H753AI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H753AI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H753AI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H753AI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H753BI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H753BI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H753BI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H753BI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H753II = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H753II.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H753II",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H753II",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H753VI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H753VI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H753VI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H753VI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H753XI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H753XI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H753XI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H753XI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H753ZI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H753ZI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H753ZI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H753ZI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x30000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x38000000, .length = 0x10000, .access = .rwx },
            },
        },
    };

    ret.STM32H755BI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H755BI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H755BI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H755BI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x10000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x18000000, .length = 0x10000, .access = .rwx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
            },
        },
    };

    ret.STM32H755II = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H755II.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H755II",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H755II",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x10000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x18000000, .length = 0x10000, .access = .rwx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
            },
        },
    };

    ret.STM32H755XI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H755XI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H755XI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H755XI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x10000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x18000000, .length = 0x10000, .access = .rwx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
            },
        },
    };

    ret.STM32H755ZI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H755ZI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H755ZI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H755ZI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x10000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x18000000, .length = 0x10000, .access = .rwx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
            },
        },
    };

    ret.STM32H757AI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H757AI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H757AI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H757AI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x10000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x18000000, .length = 0x10000, .access = .rwx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
            },
        },
    };

    ret.STM32H757BI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H757BI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H757BI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H757BI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x10000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x18000000, .length = 0x10000, .access = .rwx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
            },
        },
    };

    ret.STM32H757II = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H757II.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H757II",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H757II",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x10000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x18000000, .length = 0x10000, .access = .rwx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
            },
        },
    };

    ret.STM32H757XI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H757XI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H757XI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H757XI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x10000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x18000000, .length = 0x10000, .access = .rwx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
            },
        },
    };

    ret.STM32H757ZI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H757ZI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H757ZI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H757ZI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "RAM_D2", .tag = .ram, .offset = 0x10000000, .length = 0x48000, .access = .rwx },
                .{ .name = "RAM_D3", .tag = .ram, .offset = 0x18000000, .length = 0x10000, .access = .rwx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "RAM_D1", .tag = .ram, .offset = 0x24000000, .length = 0x80000, .access = .rwx },
            },
        },
    };

    ret.STM32H7A3AG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7A3AG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7A3AG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7A3AG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x24000000, .length = 0x100000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32H7A3AI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7A3AI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7A3AI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7A3AI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x24000000, .length = 0x100000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32H7A3IG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7A3IG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7A3IG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7A3IG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x24000000, .length = 0x100000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32H7A3II = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7A3II.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7A3II",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7A3II",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x24000000, .length = 0x100000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32H7A3LG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7A3LG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7A3LG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7A3LG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x24000000, .length = 0x100000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32H7A3LI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7A3LI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7A3LI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7A3LI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x24000000, .length = 0x100000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32H7A3NG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7A3NG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7A3NG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7A3NG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x24000000, .length = 0x100000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32H7A3NI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7A3NI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7A3NI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7A3NI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x24000000, .length = 0x100000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32H7A3QI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7A3QI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7A3QI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7A3QI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x24000000, .length = 0x100000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32H7A3RG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7A3RG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7A3RG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7A3RG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x24000000, .length = 0x100000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32H7A3RI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7A3RI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7A3RI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7A3RI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x24000000, .length = 0x100000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32H7A3VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7A3VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7A3VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7A3VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x24000000, .length = 0x100000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32H7A3VI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7A3VI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7A3VI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7A3VI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x24000000, .length = 0x100000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32H7A3ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7A3ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7A3ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7A3ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x80000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x24000000, .length = 0x100000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32H7A3ZI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7A3ZI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7A3ZI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7A3ZI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x24000000, .length = 0x100000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32H7B0AB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7B0AB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7B0AB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7B0AB",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x24000000, .length = 0x100000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32H7B0IB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7B0IB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7B0IB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7B0IB",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x24000000, .length = 0x100000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32H7B0RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7B0RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7B0RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7B0RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x24000000, .length = 0x100000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32H7B0VB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7B0VB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7B0VB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7B0VB",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x24000000, .length = 0x100000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32H7B0ZB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7B0ZB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7B0ZB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7B0ZB",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x24000000, .length = 0x100000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32H7B3AI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7B3AI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7B3AI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7B3AI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x24000000, .length = 0x100000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32H7B3II = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7B3II.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7B3II",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7B3II",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x24000000, .length = 0x100000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32H7B3LI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7B3LI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7B3LI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7B3LI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x24000000, .length = 0x100000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32H7B3NI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7B3NI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7B3NI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7B3NI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x24000000, .length = 0x100000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32H7B3QI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7B3QI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7B3QI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7B3QI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x24000000, .length = 0x100000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32H7B3RI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7B3RI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7B3RI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7B3RI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x24000000, .length = 0x100000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32H7B3VI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7B3VI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7B3VI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7B3VI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x24000000, .length = 0x100000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32H7B3ZI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7B3ZI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7B3ZI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7B3ZI",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x10000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x24000000, .length = 0x100000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32H7R3A8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7R3A8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7R3A8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7R3A8",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x30000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x24000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x24020000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x24040000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM4", .tag = .ram, .offset = 0x24060000, .length = 0x12000, .access = .rwx },
                .{ .name = "AHB_SRAM1", .tag = .ram, .offset = 0x30000000, .length = 0x4000, .access = .rwx },
                .{ .name = "AHB_SRAM2", .tag = .ram, .offset = 0x30004000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H7R3I8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7R3I8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7R3I8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7R3I8",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x30000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x24000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x24020000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x24040000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM4", .tag = .ram, .offset = 0x24060000, .length = 0x12000, .access = .rwx },
                .{ .name = "AHB_SRAM1", .tag = .ram, .offset = 0x30000000, .length = 0x4000, .access = .rwx },
                .{ .name = "AHB_SRAM2", .tag = .ram, .offset = 0x30004000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H7R3L8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7R3L8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7R3L8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7R3L8",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x30000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x24000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x24020000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x24040000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM4", .tag = .ram, .offset = 0x24060000, .length = 0x12000, .access = .rwx },
                .{ .name = "AHB_SRAM1", .tag = .ram, .offset = 0x30000000, .length = 0x4000, .access = .rwx },
                .{ .name = "AHB_SRAM2", .tag = .ram, .offset = 0x30004000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H7R3R8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7R3R8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7R3R8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7R3R8",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x30000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x24000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x24020000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x24040000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM4", .tag = .ram, .offset = 0x24060000, .length = 0x12000, .access = .rwx },
                .{ .name = "AHB_SRAM1", .tag = .ram, .offset = 0x30000000, .length = 0x4000, .access = .rwx },
                .{ .name = "AHB_SRAM2", .tag = .ram, .offset = 0x30004000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H7R3V8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7R3V8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7R3V8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7R3V8",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x30000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x24000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x24020000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x24040000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM4", .tag = .ram, .offset = 0x24060000, .length = 0x12000, .access = .rwx },
                .{ .name = "AHB_SRAM1", .tag = .ram, .offset = 0x30000000, .length = 0x4000, .access = .rwx },
                .{ .name = "AHB_SRAM2", .tag = .ram, .offset = 0x30004000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H7R3Z8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7R3Z8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7R3Z8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7R3Z8",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x30000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x24000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x24020000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x24040000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM4", .tag = .ram, .offset = 0x24060000, .length = 0x12000, .access = .rwx },
                .{ .name = "AHB_SRAM1", .tag = .ram, .offset = 0x30000000, .length = 0x4000, .access = .rwx },
                .{ .name = "AHB_SRAM2", .tag = .ram, .offset = 0x30004000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H7R7A8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7R7A8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7R7A8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7R7A8",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x30000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x24000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x24020000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x24040000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM4", .tag = .ram, .offset = 0x24060000, .length = 0x12000, .access = .rwx },
                .{ .name = "AHB_SRAM1", .tag = .ram, .offset = 0x30000000, .length = 0x4000, .access = .rwx },
                .{ .name = "AHB_SRAM2", .tag = .ram, .offset = 0x30004000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H7R7I8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7R7I8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7R7I8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7R7I8",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x30000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x24000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x24020000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x24040000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM4", .tag = .ram, .offset = 0x24060000, .length = 0x12000, .access = .rwx },
                .{ .name = "AHB_SRAM1", .tag = .ram, .offset = 0x30000000, .length = 0x4000, .access = .rwx },
                .{ .name = "AHB_SRAM2", .tag = .ram, .offset = 0x30004000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H7R7L8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7R7L8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7R7L8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7R7L8",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x30000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x24000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x24020000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x24040000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM4", .tag = .ram, .offset = 0x24060000, .length = 0x12000, .access = .rwx },
                .{ .name = "AHB_SRAM1", .tag = .ram, .offset = 0x30000000, .length = 0x4000, .access = .rwx },
                .{ .name = "AHB_SRAM2", .tag = .ram, .offset = 0x30004000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H7R7Z8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7R7Z8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7R7Z8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7R7Z8",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x30000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x24000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x24020000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x24040000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM4", .tag = .ram, .offset = 0x24060000, .length = 0x12000, .access = .rwx },
                .{ .name = "AHB_SRAM1", .tag = .ram, .offset = 0x30000000, .length = 0x4000, .access = .rwx },
                .{ .name = "AHB_SRAM2", .tag = .ram, .offset = 0x30004000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H7S3A8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7S3A8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7S3A8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7S3A8",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x30000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x24000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x24020000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x24040000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM4", .tag = .ram, .offset = 0x24060000, .length = 0x12000, .access = .rwx },
                .{ .name = "AHB_SRAM1", .tag = .ram, .offset = 0x30000000, .length = 0x4000, .access = .rwx },
                .{ .name = "AHB_SRAM2", .tag = .ram, .offset = 0x30004000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H7S3I8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7S3I8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7S3I8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7S3I8",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x30000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x24000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x24020000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x24040000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM4", .tag = .ram, .offset = 0x24060000, .length = 0x12000, .access = .rwx },
                .{ .name = "AHB_SRAM1", .tag = .ram, .offset = 0x30000000, .length = 0x4000, .access = .rwx },
                .{ .name = "AHB_SRAM2", .tag = .ram, .offset = 0x30004000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H7S3L8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7S3L8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7S3L8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7S3L8",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x30000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x24000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x24020000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x24040000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM4", .tag = .ram, .offset = 0x24060000, .length = 0x12000, .access = .rwx },
                .{ .name = "AHB_SRAM1", .tag = .ram, .offset = 0x30000000, .length = 0x4000, .access = .rwx },
                .{ .name = "AHB_SRAM2", .tag = .ram, .offset = 0x30004000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H7S3R8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7S3R8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7S3R8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7S3R8",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x30000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x24000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x24020000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x24040000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM4", .tag = .ram, .offset = 0x24060000, .length = 0x12000, .access = .rwx },
                .{ .name = "AHB_SRAM1", .tag = .ram, .offset = 0x30000000, .length = 0x4000, .access = .rwx },
                .{ .name = "AHB_SRAM2", .tag = .ram, .offset = 0x30004000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H7S3V8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7S3V8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7S3V8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7S3V8",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x30000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x24000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x24020000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x24040000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM4", .tag = .ram, .offset = 0x24060000, .length = 0x12000, .access = .rwx },
                .{ .name = "AHB_SRAM1", .tag = .ram, .offset = 0x30000000, .length = 0x4000, .access = .rwx },
                .{ .name = "AHB_SRAM2", .tag = .ram, .offset = 0x30004000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H7S3Z8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7S3Z8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7S3Z8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7S3Z8",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x30000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x24000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x24020000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x24040000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM4", .tag = .ram, .offset = 0x24060000, .length = 0x12000, .access = .rwx },
                .{ .name = "AHB_SRAM1", .tag = .ram, .offset = 0x30000000, .length = 0x4000, .access = .rwx },
                .{ .name = "AHB_SRAM2", .tag = .ram, .offset = 0x30004000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H7S7A8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7S7A8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7S7A8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7S7A8",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x30000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x24000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x24020000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x24040000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM4", .tag = .ram, .offset = 0x24060000, .length = 0x12000, .access = .rwx },
                .{ .name = "AHB_SRAM1", .tag = .ram, .offset = 0x30000000, .length = 0x4000, .access = .rwx },
                .{ .name = "AHB_SRAM2", .tag = .ram, .offset = 0x30004000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H7S7I8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7S7I8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7S7I8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7S7I8",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x30000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x24000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x24020000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x24040000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM4", .tag = .ram, .offset = 0x24060000, .length = 0x12000, .access = .rwx },
                .{ .name = "AHB_SRAM1", .tag = .ram, .offset = 0x30000000, .length = 0x4000, .access = .rwx },
                .{ .name = "AHB_SRAM2", .tag = .ram, .offset = 0x30004000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H7S7L8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7S7L8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7S7L8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7S7L8",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x30000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x24000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x24020000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x24040000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM4", .tag = .ram, .offset = 0x24060000, .length = 0x12000, .access = .rwx },
                .{ .name = "AHB_SRAM1", .tag = .ram, .offset = 0x30000000, .length = 0x4000, .access = .rwx },
                .{ .name = "AHB_SRAM2", .tag = .ram, .offset = 0x30004000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32H7S7Z8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32H7S7Z8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m7 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.fp_armv8d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32H7S7Z8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32H7S7Z8",
                },
            },
            .memory_regions = &.{
                .{ .name = "ITCM", .tag = .ram, .offset = 0x0, .length = 0x30000, .access = .rwx },
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "DTCM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x24000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x24020000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x24040000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM4", .tag = .ram, .offset = 0x24060000, .length = 0x12000, .access = .rwx },
                .{ .name = "AHB_SRAM1", .tag = .ram, .offset = 0x30000000, .length = 0x4000, .access = .rwx },
                .{ .name = "AHB_SRAM2", .tag = .ram, .offset = 0x30004000, .length = 0x4000, .access = .rwx },
            },
        },
    };

    ret.STM32L010C6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L010C6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L010C6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L010C6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L010F4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L010F4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L010F4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L010F4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L010K4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L010K4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L010K4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L010K4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L010K8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L010K8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L010K8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L010K8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L010R8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L010R8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L010R8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L010R8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L010RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L010RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L010RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L010RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L011D3 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L011D3.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L011D3",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L011D3",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x2000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L011D4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L011D4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L011D4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L011D4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L011E3 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L011E3.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L011E3",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L011E3",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x2000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L011E4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L011E4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L011E4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L011E4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L011F3 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L011F3.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L011F3",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L011F3",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x2000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L011F4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L011F4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L011F4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L011F4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L011G3 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L011G3.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L011G3",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L011G3",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x2000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L011G4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L011G4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L011G4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L011G4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L011K3 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L011K3.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L011K3",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L011K3",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x2000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L011K4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L011K4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L011K4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L011K4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L021D4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L021D4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L021D4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L021D4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L021F4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L021F4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L021F4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L021F4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L021G4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L021G4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L021G4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L021G4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L021K4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L021K4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L021K4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L021K4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L031C4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L031C4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L031C4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L031C4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L031C6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L031C6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L031C6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L031C6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L031E4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L031E4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L031E4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L031E4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L031E6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L031E6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L031E6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L031E6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L031F4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L031F4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L031F4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L031F4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L031F6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L031F6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L031F6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L031F6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L031G4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L031G4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L031G4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L031G4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L031G6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L031G6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L031G6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L031G6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L031K4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L031K4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L031K4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L031K4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L031K6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L031K6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L031K6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L031K6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L041C4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L041C4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L041C4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L041C4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L041C6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L041C6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L041C6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L041C6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L041E6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L041E6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L041E6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L041E6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L041F6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L041F6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L041F6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L041F6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L041G6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L041G6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L041G6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L041G6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L041K6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L041K6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L041K6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L041K6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L051C6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L051C6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L051C6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L051C6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L051C8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L051C8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L051C8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L051C8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L051K6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L051K6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L051K6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L051K6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L051K8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L051K8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L051K8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L051K8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L051R6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L051R6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L051R6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L051R6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L051R8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L051R8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L051R8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L051R8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L051T6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L051T6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L051T6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L051T6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L051T8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L051T8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L051T8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L051T8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L052C6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L052C6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L052C6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L052C6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L052C8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L052C8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L052C8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L052C8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L052K6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L052K6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L052K6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L052K6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L052K8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L052K8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L052K8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L052K8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L052R6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L052R6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L052R6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L052R6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L052R8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L052R8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L052R8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L052R8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L052T6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L052T6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L052T6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L052T6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L052T8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L052T8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L052T8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L052T8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L053C6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L053C6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L053C6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L053C6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L053C8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L053C8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L053C8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L053C8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L053R6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L053R6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L053R6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L053R6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L053R8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L053R8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L053R8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L053R8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L062C8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L062C8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L062C8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L062C8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L062K8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L062K8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L062K8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L062K8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L063C8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L063C8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L063C8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L063C8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L063R8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L063R8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L063R8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L063R8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L071C8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L071C8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L071C8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L071C8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L071CB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L071CB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L071CB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L071CB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L071CZ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L071CZ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L071CZ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L071CZ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x30000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L071K8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L071K8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L071K8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L071K8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L071KB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L071KB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L071KB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L071KB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L071KZ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L071KZ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L071KZ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L071KZ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x30000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L071RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L071RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L071RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L071RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L071RZ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L071RZ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L071RZ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L071RZ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x30000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L071V8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L071V8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L071V8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L071V8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L071VB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L071VB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L071VB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L071VB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L071VZ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L071VZ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L071VZ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L071VZ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x30000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L072CB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L072CB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L072CB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L072CB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L072CZ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L072CZ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L072CZ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L072CZ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x30000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L072KB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L072KB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L072KB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L072KB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L072KZ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L072KZ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L072KZ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L072KZ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x30000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L072RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L072RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L072RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L072RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L072RZ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L072RZ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L072RZ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L072RZ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x30000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L072V8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L072V8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L072V8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L072V8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L072VB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L072VB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L072VB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L072VB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L072VZ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L072VZ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L072VZ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L072VZ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x30000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L073CB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L073CB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L073CB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L073CB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L073CZ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L073CZ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L073CZ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L073CZ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x30000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L073RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L073RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L073RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L073RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L073RZ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L073RZ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L073RZ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L073RZ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x30000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L073V8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L073V8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L073V8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L073V8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L073VB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L073VB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L073VB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L073VB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L073VZ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L073VZ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L073VZ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L073VZ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x30000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L081CB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L081CB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L081CB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L081CB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L081CZ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L081CZ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L081CZ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L081CZ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x30000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L081KZ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L081KZ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L081KZ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L081KZ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x30000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L082CZ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L082CZ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L082CZ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L082CZ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x30000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L082KB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L082KB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L082KB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L082KB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L082KZ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L082KZ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L082KZ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L082KZ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x30000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L083CB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L083CB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L083CB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L083CB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L083CZ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L083CZ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L083CZ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L083CZ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x30000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L083RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L083RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L083RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L083RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L083RZ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L083RZ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L083RZ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L083RZ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x30000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L083V8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L083V8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L083V8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L083V8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L083VB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L083VB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L083VB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L083VB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L083VZ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L083VZ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L083VZ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L083VZ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x30000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x5000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L100C6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L100C6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L100C6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L100C6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.@"STM32L100C6-A" = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.@"STM32L100C6-A".* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L100C6-A",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L100C6-A",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x1000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L100R8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L100R8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L100R8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L100R8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.@"STM32L100R8-A" = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.@"STM32L100R8-A".* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L100R8-A",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L100R8-A",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L100RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L100RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L100RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L100RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.@"STM32L100RB-A" = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.@"STM32L100RB-A".* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L100RB-A",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L100RB-A",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L100RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L100RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L100RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L100RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L151C6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L151C6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L151C6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L151C6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.@"STM32L151C6-A" = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.@"STM32L151C6-A".* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L151C6-A",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L151C6-A",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L151C8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L151C8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L151C8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L151C8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.@"STM32L151C8-A" = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.@"STM32L151C8-A".* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L151C8-A",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L151C8-A",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L151CB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L151CB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L151CB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L151CB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.@"STM32L151CB-A" = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.@"STM32L151CB-A".* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L151CB-A",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L151CB-A",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L151CC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L151CC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L151CC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L151CC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L151QC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L151QC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L151QC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L151QC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L151QD = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L151QD.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L151QD",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L151QD",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x30000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8030000, .length = 0x30000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L151QE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L151QE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L151QE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L151QE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L151R6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L151R6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L151R6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L151R6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.@"STM32L151R6-A" = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.@"STM32L151R6-A".* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L151R6-A",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L151R6-A",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L151R8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L151R8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L151R8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L151R8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.@"STM32L151R8-A" = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.@"STM32L151R8-A".* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L151R8-A",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L151R8-A",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L151RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L151RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L151RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L151RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.@"STM32L151RB-A" = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.@"STM32L151RB-A".* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L151RB-A",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L151RB-A",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L151RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L151RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L151RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L151RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.@"STM32L151RC-A" = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.@"STM32L151RC-A".* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L151RC-A",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L151RC-A",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L151RD = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L151RD.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L151RD",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L151RD",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x30000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8030000, .length = 0x30000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L151RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L151RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L151RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L151RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L151UC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L151UC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L151UC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L151UC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L151V8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L151V8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L151V8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L151V8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.@"STM32L151V8-A" = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.@"STM32L151V8-A".* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L151V8-A",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L151V8-A",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L151VB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L151VB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L151VB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L151VB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.@"STM32L151VB-A" = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.@"STM32L151VB-A".* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L151VB-A",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L151VB-A",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L151VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L151VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L151VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L151VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.@"STM32L151VC-A" = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.@"STM32L151VC-A".* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L151VC-A",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L151VC-A",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L151VD = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L151VD.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L151VD",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L151VD",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x30000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8030000, .length = 0x30000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.@"STM32L151VD-X" = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.@"STM32L151VD-X".* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L151VD-X",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L151VD-X",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x30000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8030000, .length = 0x30000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L151VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L151VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L151VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L151VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L151ZC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L151ZC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L151ZC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L151ZC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L151ZD = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L151ZD.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L151ZD",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L151ZD",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x30000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8030000, .length = 0x30000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L151ZE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L151ZE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L151ZE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L151ZE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L152C6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L152C6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L152C6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L152C6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.@"STM32L152C6-A" = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.@"STM32L152C6-A".* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L152C6-A",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L152C6-A",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L152C8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L152C8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L152C8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L152C8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.@"STM32L152C8-A" = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.@"STM32L152C8-A".* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L152C8-A",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L152C8-A",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L152CB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L152CB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L152CB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L152CB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.@"STM32L152CB-A" = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.@"STM32L152CB-A".* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L152CB-A",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L152CB-A",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L152CC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L152CC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L152CC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L152CC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L152QC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L152QC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L152QC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L152QC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L152QD = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L152QD.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L152QD",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L152QD",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x30000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8030000, .length = 0x30000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L152QE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L152QE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L152QE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L152QE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L152R6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L152R6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L152R6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L152R6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.@"STM32L152R6-A" = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.@"STM32L152R6-A".* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L152R6-A",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L152R6-A",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L152R8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L152R8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L152R8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L152R8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.@"STM32L152R8-A" = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.@"STM32L152R8-A".* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L152R8-A",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L152R8-A",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L152RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L152RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L152RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L152RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.@"STM32L152RB-A" = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.@"STM32L152RB-A".* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L152RB-A",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L152RB-A",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L152RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L152RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L152RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L152RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.@"STM32L152RC-A" = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.@"STM32L152RC-A".* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L152RC-A",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L152RC-A",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L152RD = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L152RD.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L152RD",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L152RD",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x30000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8030000, .length = 0x30000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L152RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L152RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L152RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L152RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L152UC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L152UC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L152UC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L152UC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L152V8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L152V8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L152V8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L152V8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x2800, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.@"STM32L152V8-A" = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.@"STM32L152V8-A".* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L152V8-A",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L152V8-A",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L152VB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L152VB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L152VB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L152VB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.@"STM32L152VB-A" = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.@"STM32L152VB-A".* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L152VB-A",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L152VB-A",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L152VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L152VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L152VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L152VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.@"STM32L152VC-A" = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.@"STM32L152VC-A".* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L152VC-A",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L152VC-A",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L152VD = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L152VD.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L152VD",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L152VD",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x30000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8030000, .length = 0x30000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.@"STM32L152VD-X" = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.@"STM32L152VD-X".* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L152VD-X",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L152VD-X",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x30000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8030000, .length = 0x30000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L152VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L152VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L152VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L152VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L152ZC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L152ZC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L152ZC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L152ZC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L152ZD = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L152ZD.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L152ZD",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L152ZD",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x30000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8030000, .length = 0x30000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L152ZE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L152ZE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L152ZE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L152ZE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L162QC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L162QC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L162QC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L162QC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L162QD = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L162QD.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L162QD",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L162QD",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x30000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8030000, .length = 0x30000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L162RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L162RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L162RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L162RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.@"STM32L162RC-A" = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.@"STM32L162RC-A".* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L162RC-A",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L162RC-A",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L162RD = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L162RD.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L162RD",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L162RD",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x30000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8030000, .length = 0x30000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L162RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L162RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L162RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L162RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L162VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L162VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L162VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L162VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.@"STM32L162VC-A" = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.@"STM32L162VC-A".* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L162VC-A",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L162VC-A",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L162VD = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L162VD.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L162VD",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L162VD",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x30000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8030000, .length = 0x30000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.@"STM32L162VD-X" = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.@"STM32L162VD-X".* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L162VD-X",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L162VD-X",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x30000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8030000, .length = 0x30000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L162VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L162VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L162VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L162VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L162ZC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L162ZC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L162ZC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L162ZC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L162ZD = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L162ZD.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L162ZD",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L162ZD",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x30000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8030000, .length = 0x30000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L162ZE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L162ZE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32L162ZE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L162ZE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x14000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L412C8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L412C8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L412C8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L412C8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x2000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20008000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L412CB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L412CB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L412CB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L412CB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x2000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20008000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L412K8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L412K8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L412K8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L412K8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x2000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20008000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L412KB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L412KB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L412KB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L412KB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x2000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20008000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L412R8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L412R8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L412R8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L412R8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x2000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20008000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L412RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L412RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L412RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L412RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x2000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20008000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L412T8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L412T8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L412T8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L412T8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x2000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20008000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L412TB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L412TB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L412TB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L412TB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x2000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20008000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L422CB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L422CB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L422CB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L422CB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x2000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20008000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L422KB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L422KB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L422KB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L422KB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x2000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20008000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L422RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L422RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L422RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L422RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x2000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20008000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L422TB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L422TB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L422TB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L422TB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x2000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20008000, .length = 0x2000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L431CB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L431CB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L431CB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L431CB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2000C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L431CC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L431CC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L431CC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L431CC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2000C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L431KB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L431KB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L431KB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L431KB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2000C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L431KC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L431KC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L431KC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L431KC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2000C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L431RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L431RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L431RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L431RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2000C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L431RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L431RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L431RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L431RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2000C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L431VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L431VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L431VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L431VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2000C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L432KB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L432KB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L432KB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L432KB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2000C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L432KC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L432KC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L432KC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L432KC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2000C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L433CB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L433CB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L433CB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L433CB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2000C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L433CC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L433CC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L433CC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L433CC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2000C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L433RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L433RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L433RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L433RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2000C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L433RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L433RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L433RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L433RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2000C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L433VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L433VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L433VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L433VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2000C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L442KC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L442KC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L442KC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L442KC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2000C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L443CC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L443CC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L443CC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L443CC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2000C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L443RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L443RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L443RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L443RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2000C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L443VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L443VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L443VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L443VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x4000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x2000C000, .length = 0x4000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L451CC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L451CC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L451CC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L451CC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20020000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L451CE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L451CE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L451CE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L451CE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20020000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L451RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L451RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L451RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L451RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20020000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L451RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L451RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L451RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L451RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20020000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L451VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L451VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L451VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L451VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20020000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L451VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L451VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L451VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L451VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20020000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L452CC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L452CC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L452CC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L452CC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20020000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L452CE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L452CE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L452CE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L452CE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20020000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L452RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L452RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L452RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L452RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20020000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L452RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L452RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L452RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L452RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20020000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L452VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L452VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L452VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L452VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20020000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L452VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L452VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L452VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L452VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20020000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L462CE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L462CE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L462CE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L462CE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20020000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L462RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L462RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L462RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L462RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20020000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L462VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L462VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L462VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L462VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20020000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L471QE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L471QE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L471QE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L471QE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32L47X.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32L471QG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L471QG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L471QG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L471QG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32L47X.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32L471RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L471RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L471RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L471RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32L47X.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32L471RG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L471RG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L471RG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L471RG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32L47X.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32L471VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L471VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L471VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L471VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32L47X.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32L471VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L471VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L471VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L471VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32L47X.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32L471ZE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L471ZE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L471ZE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L471ZE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32L47X.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32L471ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L471ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L471ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L471ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32L47X.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32L475RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L475RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L475RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L475RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8020000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32L47X.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32L475RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L475RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L475RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L475RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32L47X.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32L475RG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L475RG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L475RG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L475RG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32L47X.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32L475VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L475VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L475VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L475VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8020000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32L47X.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32L475VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L475VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L475VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L475VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32L47X.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32L475VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L475VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L475VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L475VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32L47X.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32L476JE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L476JE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L476JE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L476JE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32L47X.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32L476JG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L476JG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L476JG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L476JG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32L47X.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32L476ME = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L476ME.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L476ME",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L476ME",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32L47X.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32L476MG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L476MG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L476MG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L476MG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32L47X.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32L476QE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L476QE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L476QE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L476QE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32L47X.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32L476QG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L476QG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L476QG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L476QG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32L47X.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32L476RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L476RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L476RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L476RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8020000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32L47X.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32L476RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L476RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L476RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L476RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32L47X.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32L476RG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L476RG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L476RG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L476RG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32L47X.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32L476VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L476VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L476VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L476VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8020000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32L47X.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32L476VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L476VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L476VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L476VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32L47X.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32L476VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L476VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L476VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L476VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32L47X.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32L476ZE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L476ZE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L476ZE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L476ZE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32L47X.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32L476ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L476ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L476ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L476ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
        .hal = .{
            .root_source_file = b.path("src/hals/STM32L47X.zig"),
            .imports = hal_imports,
        },
    };

    ret.STM32L486JG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L486JG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L486JG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L486JG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L486QG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L486QG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L486QG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L486QG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L486RG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L486RG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L486RG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L486RG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L486VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L486VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L486VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L486VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L486ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L486ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L486ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L486ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L496AE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L496AE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L496AE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L496AE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L496AG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L496AG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L496AG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L496AG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L496QE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L496QE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L496QE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L496QE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L496QG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L496QG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L496QG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L496QG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L496RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L496RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L496RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L496RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L496RG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L496RG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L496RG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L496RG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L496VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L496VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L496VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L496VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L496VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L496VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L496VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L496VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L496WG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L496WG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L496WG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L496WG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L496ZE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L496ZE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L496ZE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L496ZE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L496ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L496ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L496ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L496ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4A6AG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4A6AG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4A6AG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4A6AG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4A6QG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4A6QG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4A6QG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4A6QG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4A6RG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4A6RG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4A6RG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4A6RG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4A6VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4A6VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4A6VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4A6VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4A6ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4A6ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4A6ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4A6ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20040000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4P5AE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4P5AE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4P5AE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4P5AE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4P5AG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4P5AG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4P5AG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4P5AG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4P5CE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4P5CE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4P5CE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4P5CE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4P5CG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4P5CG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4P5CG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4P5CG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4P5QE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4P5QE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4P5QE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4P5QE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4P5QG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4P5QG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4P5QG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4P5QG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4P5RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4P5RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4P5RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4P5RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4P5RG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4P5RG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4P5RG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4P5RG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4P5VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4P5VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4P5VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4P5VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4P5VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4P5VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4P5VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4P5VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4P5ZE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4P5ZE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4P5ZE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4P5ZE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4P5ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4P5ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4P5ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4P5ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4Q5AG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4Q5AG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4Q5AG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4Q5AG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4Q5CG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4Q5CG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4Q5CG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4Q5CG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4Q5QG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4Q5QG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4Q5QG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4Q5QG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4Q5RG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4Q5RG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4Q5RG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4Q5RG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4Q5VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4Q5VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4Q5VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4Q5VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4Q5ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4Q5ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4Q5ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4Q5ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x50000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4R5AG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4R5AG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4R5AG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4R5AG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4R5AI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4R5AI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4R5AI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4R5AI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4R5QG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4R5QG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4R5QG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4R5QG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4R5QI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4R5QI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4R5QI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4R5QI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4R5VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4R5VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4R5VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4R5VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4R5VI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4R5VI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4R5VI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4R5VI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4R5ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4R5ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4R5ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4R5ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4R5ZI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4R5ZI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4R5ZI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4R5ZI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4R7AI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4R7AI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4R7AI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4R7AI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4R7VI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4R7VI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4R7VI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4R7VI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4R7ZI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4R7ZI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4R7ZI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4R7ZI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4R9AG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4R9AG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4R9AG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4R9AG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4R9AI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4R9AI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4R9AI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4R9AI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4R9VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4R9VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4R9VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4R9VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4R9VI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4R9VI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4R9VI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4R9VI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4R9ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4R9ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4R9ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4R9ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4R9ZI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4R9ZI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4R9ZI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4R9ZI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4S5AI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4S5AI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4S5AI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4S5AI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4S5QI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4S5QI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4S5QI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4S5QI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4S5VI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4S5VI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4S5VI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4S5VI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4S5ZI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4S5ZI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4S5ZI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4S5ZI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4S7AI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4S7AI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4S7AI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4S7AI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4S7VI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4S7VI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4S7VI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4S7VI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4S7ZI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4S7ZI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4S7ZI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4S7ZI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4S9AI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4S9AI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4S9AI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4S9AI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4S9VI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4S9VI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4S9VI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4S9VI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L4S9ZI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L4S9ZI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L4S9ZI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L4S9ZI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L552CC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L552CC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L552CC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L552CC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L552CE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L552CE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L552CE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L552CE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L552ME = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L552ME.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L552ME",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L552ME",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L552QC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L552QC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L552QC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L552QC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L552QE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L552QE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L552QE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L552QE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L552RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L552RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L552RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L552RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L552RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L552RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L552RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L552RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L552VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L552VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L552VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L552VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L552VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L552VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L552VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L552VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L552ZC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L552ZC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L552ZC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L552ZC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L552ZE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L552ZE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L552ZE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L552ZE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L562CE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L562CE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L562CE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L562CE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L562ME = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L562ME.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L562ME",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L562ME",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L562QE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L562QE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L562QE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L562QE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L562RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L562RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L562RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L562RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L562VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L562VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L562VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L562VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32L562ZE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32L562ZE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32L562ZE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32L562ZE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x40000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U031C6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U031C6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32U031C6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U031C6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x3000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U031C8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U031C8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32U031C8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U031C8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x3000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U031F4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U031F4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32U031F4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U031F4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x3000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U031F6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U031F6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32U031F6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U031F6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x3000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U031F8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U031F8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32U031F8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U031F8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x3000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U031G6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U031G6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32U031G6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U031G6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x3000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U031G8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U031G8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32U031G8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U031G8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x3000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U031K4 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U031K4.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32U031K4",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U031K4",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x4000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x3000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U031K6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U031K6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32U031K6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U031K6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x3000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U031K8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U031K8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32U031K8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U031K8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x3000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U031R6 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U031R6.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32U031R6",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U031R6",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x8000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x3000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U031R8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U031R8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32U031R8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U031R8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x3000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U073C8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U073C8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32U073C8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U073C8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U073CB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U073CB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32U073CB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U073CB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U073CC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U073CC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32U073CC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U073CC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U073H8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U073H8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32U073H8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U073H8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U073HB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U073HB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32U073HB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U073HB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U073HC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U073HC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32U073HC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U073HC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U073K8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U073K8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32U073K8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U073K8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U073KB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U073KB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32U073KB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U073KB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U073KC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U073KC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32U073KC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U073KC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U073M8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U073M8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32U073M8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U073M8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U073MB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U073MB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32U073MB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U073MB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U073MC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U073MC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32U073MC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U073MC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U073R8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U073R8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32U073R8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U073R8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U073RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U073RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32U073RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U073RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U073RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U073RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32U073RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U073RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U083CC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U083CC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32U083CC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U083CC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U083HC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U083HC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32U083HC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U083HC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U083KC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U083KC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32U083KC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U083KC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U083MC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U083MC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32U083MC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U083MC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U083RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U083RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32U083RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U083RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xA000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U535CB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U535CB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U535CB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U535CB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8010000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20030000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U535CC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U535CC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U535CC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U535CC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8020000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20030000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U535CE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U535CE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U535CE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U535CE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20030000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U535JE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U535JE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U535JE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U535JE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20030000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U535NC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U535NC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U535NC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U535NC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8020000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20030000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U535NE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U535NE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U535NE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U535NE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20030000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U535RB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U535RB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U535RB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U535RB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8010000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20030000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U535RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U535RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U535RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U535RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8020000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20030000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U535RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U535RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U535RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U535RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20030000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U535VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U535VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U535VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U535VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8020000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20030000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U535VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U535VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U535VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U535VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20030000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U545CE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U545CE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U545CE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U545CE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20030000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U545JE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U545JE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U545JE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U545JE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20030000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U545NE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U545NE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U545NE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U545NE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20030000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U545RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U545RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U545RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U545RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20030000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U545VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U545VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U545VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U545VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8040000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20030000, .length = 0x10000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U575AG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U575AG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U575AG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U575AG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20030000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20040000, .length = 0x80000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U575AI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U575AI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U575AI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U575AI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20030000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20040000, .length = 0x80000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U575CG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U575CG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U575CG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U575CG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20030000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20040000, .length = 0x80000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U575CI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U575CI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U575CI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U575CI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20030000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20040000, .length = 0x80000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U575OG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U575OG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U575OG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U575OG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20030000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20040000, .length = 0x80000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U575OI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U575OI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U575OI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U575OI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20030000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20040000, .length = 0x80000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U575QG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U575QG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U575QG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U575QG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20030000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20040000, .length = 0x80000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U575QI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U575QI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U575QI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U575QI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20030000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20040000, .length = 0x80000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U575RG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U575RG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U575RG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U575RG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20030000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20040000, .length = 0x80000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U575RI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U575RI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U575RI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U575RI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20030000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20040000, .length = 0x80000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U575VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U575VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U575VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U575VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20030000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20040000, .length = 0x80000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U575VI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U575VI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U575VI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U575VI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20030000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20040000, .length = 0x80000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U575ZG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U575ZG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U575ZG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U575ZG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8080000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20030000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20040000, .length = 0x80000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U575ZI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U575ZI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U575ZI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U575ZI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20030000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20040000, .length = 0x80000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U585AI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U585AI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U585AI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U585AI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20030000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20040000, .length = 0x80000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U585CI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U585CI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U585CI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U585CI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20030000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20040000, .length = 0x80000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U585OI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U585OI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U585OI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U585OI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20030000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20040000, .length = 0x80000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U585QI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U585QI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U585QI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U585QI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20030000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20040000, .length = 0x80000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U585RI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U585RI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U585RI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U585RI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20030000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20040000, .length = 0x80000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U585VI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U585VI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U585VI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U585VI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20030000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20040000, .length = 0x80000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U585ZI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U585ZI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U585ZI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U585ZI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20030000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x20040000, .length = 0x80000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U595AI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U595AI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U595AI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U595AI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U595AJ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U595AJ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U595AJ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U595AJ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8200000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U595QI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U595QI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U595QI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U595QI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U595QJ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U595QJ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U595QJ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U595QJ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8200000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U595RI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U595RI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U595RI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U595RI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U595RJ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U595RJ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U595RJ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U595RJ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8200000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U595VI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U595VI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U595VI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U595VI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U595VJ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U595VJ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U595VJ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U595VJ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8200000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U595ZI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U595ZI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U595ZI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U595ZI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U595ZJ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U595ZJ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U595ZJ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U595ZJ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8200000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U599BJ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U599BJ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U599BJ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U599BJ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8200000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U599NI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U599NI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U599NI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U599NI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U599NJ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U599NJ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U599NJ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U599NJ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8200000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U599VI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U599VI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U599VI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U599VI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U599VJ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U599VJ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U599VJ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U599VJ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8200000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U599ZI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U599ZI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U599ZI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U599ZI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U599ZJ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U599ZJ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U599ZJ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U599ZJ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8200000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U5A5AJ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U5A5AJ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U5A5AJ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U5A5AJ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8200000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U5A5QI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U5A5QI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U5A5QI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U5A5QI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8100000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U5A5QJ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U5A5QJ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U5A5QJ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U5A5QJ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8200000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U5A5RJ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U5A5RJ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U5A5RJ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U5A5RJ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8200000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U5A5VJ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U5A5VJ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U5A5VJ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U5A5VJ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8200000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U5A5ZJ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U5A5ZJ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U5A5ZJ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U5A5ZJ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8200000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U5A9BJ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U5A9BJ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U5A9BJ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U5A9BJ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8200000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U5A9NJ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U5A9NJ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U5A9NJ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U5A9NJ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8200000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U5A9VJ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U5A9VJ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U5A9VJ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U5A9VJ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8200000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U5A9ZJ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U5A9ZJ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U5A9ZJ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U5A9ZJ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8200000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U5F7VI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U5F7VI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U5F7VI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U5F7VI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8200000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM6", .tag = .ram, .offset = 0x20270000, .length = 0x80000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U5F7VJ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U5F7VJ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U5F7VJ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U5F7VJ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8200000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM6", .tag = .ram, .offset = 0x20270000, .length = 0x80000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U5F9BJ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U5F9BJ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U5F9BJ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U5F9BJ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8200000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM6", .tag = .ram, .offset = 0x20270000, .length = 0x80000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U5F9NJ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U5F9NJ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U5F9NJ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U5F9NJ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8200000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM6", .tag = .ram, .offset = 0x20270000, .length = 0x80000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U5F9VI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U5F9VI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U5F9VI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U5F9VI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8200000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM6", .tag = .ram, .offset = 0x20270000, .length = 0x80000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U5F9VJ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U5F9VJ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U5F9VJ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U5F9VJ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8200000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM6", .tag = .ram, .offset = 0x20270000, .length = 0x80000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U5F9ZI = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U5F9ZI.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U5F9ZI",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U5F9ZI",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8200000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM6", .tag = .ram, .offset = 0x20270000, .length = 0x80000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U5F9ZJ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U5F9ZJ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U5F9ZJ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U5F9ZJ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8200000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM6", .tag = .ram, .offset = 0x20270000, .length = 0x80000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U5G7VJ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U5G7VJ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U5G7VJ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U5G7VJ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8200000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM6", .tag = .ram, .offset = 0x20270000, .length = 0x80000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U5G9BJ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U5G9BJ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U5G9BJ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U5G9BJ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8200000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM6", .tag = .ram, .offset = 0x20270000, .length = 0x80000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U5G9NJ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U5G9NJ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U5G9NJ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U5G9NJ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8200000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM6", .tag = .ram, .offset = 0x20270000, .length = 0x80000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U5G9VJ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U5G9VJ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U5G9VJ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U5G9VJ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8200000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM6", .tag = .ram, .offset = 0x20270000, .length = 0x80000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32U5G9ZJ = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32U5G9ZJ.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32U5G9ZJ",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32U5G9ZJ",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x200000, .access = .rx },
                .{ .name = "BANK_2", .tag = .flash, .offset = 0x8200000, .length = 0x200000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0xC0000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x200C0000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM3", .tag = .ram, .offset = 0x200D0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM5", .tag = .ram, .offset = 0x201A0000, .length = 0xD0000, .access = .rwx },
                .{ .name = "SRAM6", .tag = .ram, .offset = 0x20270000, .length = 0x80000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32WB10CC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WB10CC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32WB10CC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WB10CC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x50000, .access = .rx },
                .{ .name = "SRAM2A_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2B_ICODE", .tag = .ram, .offset = 0x10008000, .length = 0x1000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x3000, .access = .rwx },
                .{ .name = "SRAM2A", .tag = .ram, .offset = 0x20030000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2B", .tag = .ram, .offset = 0x20038000, .length = 0x1000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32WB15CC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WB15CC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32WB15CC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WB15CC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x50000, .access = .rx },
                .{ .name = "SRAM2A_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2B_ICODE", .tag = .ram, .offset = 0x10008000, .length = 0x1000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x3000, .access = .rwx },
                .{ .name = "SRAM2A", .tag = .ram, .offset = 0x20030000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2B", .tag = .ram, .offset = 0x20038000, .length = 0x1000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32WB30CE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WB30CE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32WB30CE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WB30CE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2A_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2B_ICODE", .tag = .ram, .offset = 0x10008000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2A", .tag = .ram, .offset = 0x20030000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2B", .tag = .ram, .offset = 0x20038000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32WB35CC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WB35CC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32WB35CC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WB35CC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2A_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2B_ICODE", .tag = .ram, .offset = 0x10008000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2A", .tag = .ram, .offset = 0x20030000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2B", .tag = .ram, .offset = 0x20038000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32WB35CE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WB35CE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32WB35CE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WB35CE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2A_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2B_ICODE", .tag = .ram, .offset = 0x10008000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2A", .tag = .ram, .offset = 0x20030000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2B", .tag = .ram, .offset = 0x20038000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32WB50CG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WB50CG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32WB50CG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WB50CG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM2A_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2B_ICODE", .tag = .ram, .offset = 0x10008000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM2A", .tag = .ram, .offset = 0x20030000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2B", .tag = .ram, .offset = 0x20038000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32WB55CC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WB55CC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32WB55CC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WB55CC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2A_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2B_ICODE", .tag = .ram, .offset = 0x10008000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM2A", .tag = .ram, .offset = 0x20030000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2B", .tag = .ram, .offset = 0x20038000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32WB55CE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WB55CE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32WB55CE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WB55CE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2A_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2B_ICODE", .tag = .ram, .offset = 0x10008000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2A", .tag = .ram, .offset = 0x20030000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2B", .tag = .ram, .offset = 0x20038000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32WB55CG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WB55CG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32WB55CG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WB55CG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM2A_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2B_ICODE", .tag = .ram, .offset = 0x10008000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2A", .tag = .ram, .offset = 0x20030000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2B", .tag = .ram, .offset = 0x20038000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32WB55RC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WB55RC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32WB55RC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WB55RC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2A_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2B_ICODE", .tag = .ram, .offset = 0x10008000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM2A", .tag = .ram, .offset = 0x20030000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2B", .tag = .ram, .offset = 0x20038000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32WB55RE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WB55RE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32WB55RE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WB55RE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2A_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2B_ICODE", .tag = .ram, .offset = 0x10008000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2A", .tag = .ram, .offset = 0x20030000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2B", .tag = .ram, .offset = 0x20038000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32WB55RG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WB55RG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32WB55RG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WB55RG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM2A_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2B_ICODE", .tag = .ram, .offset = 0x10008000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2A", .tag = .ram, .offset = 0x20030000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2B", .tag = .ram, .offset = 0x20038000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32WB55VC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WB55VC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32WB55VC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WB55VC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM2A_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2B_ICODE", .tag = .ram, .offset = 0x10008000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x10000, .access = .rwx },
                .{ .name = "SRAM2A", .tag = .ram, .offset = 0x20030000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2B", .tag = .ram, .offset = 0x20038000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32WB55VE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WB55VE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32WB55VE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WB55VE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM2A_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2B_ICODE", .tag = .ram, .offset = 0x10008000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2A", .tag = .ram, .offset = 0x20030000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2B", .tag = .ram, .offset = 0x20038000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32WB55VG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WB55VG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32WB55VG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WB55VG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM2A_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2B_ICODE", .tag = .ram, .offset = 0x10008000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2A", .tag = .ram, .offset = 0x20030000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2B", .tag = .ram, .offset = 0x20038000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32WB55VY = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WB55VY.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32WB55VY",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WB55VY",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0xA0000, .access = .rx },
                .{ .name = "SRAM2A_ICODE", .tag = .ram, .offset = 0x10000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2B_ICODE", .tag = .ram, .offset = 0x10008000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x30000, .access = .rwx },
                .{ .name = "SRAM2A", .tag = .ram, .offset = 0x20030000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2B", .tag = .ram, .offset = 0x20038000, .length = 0x8000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32WBA50KE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WBA50KE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32WBA50KE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WBA50KE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32WBA50KG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WBA50KG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32WBA50KG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WBA50KG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32WBA52CE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WBA52CE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32WBA52CE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WBA52CE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32WBA52CG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WBA52CG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32WBA52CG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WBA52CG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32WBA52KE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WBA52KE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32WBA52KE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WBA52KE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32WBA52KG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WBA52KG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32WBA52KG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WBA52KG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32WBA54CE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WBA54CE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32WBA54CE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WBA54CE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32WBA54CG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WBA54CG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32WBA54CG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WBA54CG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32WBA54KE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WBA54KE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32WBA54KE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WBA54KE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32WBA54KG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WBA54KG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32WBA54KG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WBA54KG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32WBA55CE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WBA55CE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32WBA55CE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WBA55CE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32WBA55CG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WBA55CG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32WBA55CG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WBA55CG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32WBA55HE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WBA55HE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32WBA55HE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WBA55HE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32WBA55HG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WBA55HG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32WBA55HG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WBA55HG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32WBA55UE = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WBA55UE.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32WBA55UE",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WBA55UE",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x80000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x18000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32WBA55UG = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WBA55UG.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
            .os_tag = .freestanding,
            .cpu_features_add = std.Target.arm.featureSet(&.{.vfp4d16sp}),
            .abi = .eabihf,
        },
        .chip = .{
            .name = "STM32WBA55UG",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WBA55UG",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x100000, .access = .rx },
                .{ .name = "SRAM", .tag = .ram, .offset = 0x20000000, .length = 0x20000, .access = .rwx },
            },
        },
        .linker_script = .{
            .file = b.path("ld/dma_sram.ld"),
        },
    };

    ret.STM32WL54CC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WL54CC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32WL54CC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WL54CC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20008000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32WL54JC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WL54JC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32WL54JC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WL54JC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20008000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32WL55CC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WL55CC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32WL55CC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WL55CC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20008000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32WL55JC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WL55JC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32WL55JC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WL55JC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20008000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32WLE4C8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WLE4C8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32WLE4C8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WLE4C8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x2800, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20002800, .length = 0x2800, .access = .rwx },
            },
        },
    };

    ret.STM32WLE4CB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WLE4CB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32WLE4CB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WLE4CB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x6000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20006000, .length = 0x6000, .access = .rwx },
            },
        },
    };

    ret.STM32WLE4CC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WLE4CC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32WLE4CC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WLE4CC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20008000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32WLE4J8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WLE4J8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32WLE4J8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WLE4J8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x2800, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20002800, .length = 0x2800, .access = .rwx },
            },
        },
    };

    ret.STM32WLE4JB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WLE4JB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32WLE4JB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WLE4JB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x6000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20006000, .length = 0x6000, .access = .rwx },
            },
        },
    };

    ret.STM32WLE4JC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WLE4JC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32WLE4JC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WLE4JC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20008000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32WLE5C8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WLE5C8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32WLE5C8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WLE5C8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x2800, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20002800, .length = 0x2800, .access = .rwx },
            },
        },
    };

    ret.STM32WLE5CB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WLE5CB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32WLE5CB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WLE5CB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x6000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20006000, .length = 0x6000, .access = .rwx },
            },
        },
    };

    ret.STM32WLE5CC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WLE5CC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32WLE5CC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WLE5CC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20008000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    ret.STM32WLE5J8 = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WLE5J8.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32WLE5J8",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WLE5J8",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x10000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x2800, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20002800, .length = 0x2800, .access = .rwx },
            },
        },
    };

    ret.STM32WLE5JB = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WLE5JB.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32WLE5JB",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WLE5JB",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x20000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x6000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20006000, .length = 0x6000, .access = .rwx },
            },
        },
    };

    ret.STM32WLE5JC = b.allocator.create(microzig.Target) catch @panic("out of memory");
    ret.STM32WLE5JC.* = .{
        .dep = dep,
        .preferred_binary_format = .elf,
        .zig_target = .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .chip = .{
            .name = "STM32WLE5JC",
            .register_definition = .{
                .embassy = .{
                    .path = embassy,
                    .device = "STM32WLE5JC",
                },
            },
            .memory_regions = &.{
                .{ .name = "BANK_1", .tag = .flash, .offset = 0x8000000, .length = 0x40000, .access = .rx },
                .{ .name = "SRAM1", .tag = .ram, .offset = 0x20000000, .length = 0x8000, .access = .rwx },
                .{ .name = "SRAM2", .tag = .ram, .offset = 0x20008000, .length = 0x8000, .access = .rwx },
            },
        },
    };

    return ret;
}
