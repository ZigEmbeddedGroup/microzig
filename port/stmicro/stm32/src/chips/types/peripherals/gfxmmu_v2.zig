const microzig = @import("microzig");
const mmio = microzig.mmio;

const types = @import("../../types.zig");

pub const BM192 = enum(u1) {
    /// 256 blocks per line.
    @"256BlocksPerLine" = 0x0,
    /// 192 blocks per line.
    @"192BlocksPerLine" = 0x1,
};

pub const CLB = enum(u2) {
    /// Cache locked on buffer 0.
    LockedOnBuffer0 = 0x0,
    /// Cache locked on buffer 1.
    LockedOnBuffer1 = 0x1,
    /// Cache locked on buffer 2.
    LockedOnBuffer2 = 0x2,
    /// Cache locked on buffer 3.
    LockedOnBuffer3 = 0x3,
};

/// GFXMMU.
pub const GFXMMU = extern struct {
    /// GFXMMU configuration register.
    /// offset: 0x00
    CR: mmio.Mmio(packed struct(u32) {
        /// (1/4 of BOIE) Buffer overflow interrupt enable. This bit enables the buffer 0 overflow interrupt.
        @"BOIE[0]": u1,
        /// (2/4 of BOIE) Buffer overflow interrupt enable. This bit enables the buffer 0 overflow interrupt.
        @"BOIE[1]": u1,
        /// (3/4 of BOIE) Buffer overflow interrupt enable. This bit enables the buffer 0 overflow interrupt.
        @"BOIE[2]": u1,
        /// (4/4 of BOIE) Buffer overflow interrupt enable. This bit enables the buffer 0 overflow interrupt.
        @"BOIE[3]": u1,
        /// AHB master error interrupt enable. This bit enables the AHB master error interrupt.
        AMEIE: u1,
        reserved6: u1 = 0,
        /// (1/1 of BM) 192 Block mode. This bit defines the number of blocks per line.
        @"BM[0]": BM192,
        /// Cache enable. This bit enables the cache unit.
        CE: u1,
        /// Cache lock. This bit lock the cache onto the buffer defined in the CLB field.
        CL: u1,
        /// Cache lock buffer. This field select the buffer on which the cache is locked.
        CLB: CLB,
        /// Force caching. This bit force the caching into the cache regardless of the MPU attributes. The cache must be enable (CE bit set).
        FC: u1,
        /// Prefetch disable. This bit disables the prefetch of the cache.
        PD: u1,
        reserved16: u3 = 0,
        /// Outter cachability. This bit configure the cachability of an access generated by the GFXMMU cache.
        OC: u1,
        /// Outter bufferability. This bit configure the bufferability of an access generated by the GFXMMU cache.
        OB: u1,
        padding: u14 = 0,
    }),
    /// GFXMMU status register.
    /// offset: 0x04
    SR: mmio.Mmio(packed struct(u32) {
        /// (1/4 of BOF) Buffer overflow flag. This bit is set when an overflow occurs during the offset calculation of the buffer 0. It is cleared by writing 1 to CB0OF.
        @"BOF[0]": u1,
        /// (2/4 of BOF) Buffer overflow flag. This bit is set when an overflow occurs during the offset calculation of the buffer 0. It is cleared by writing 1 to CB0OF.
        @"BOF[1]": u1,
        /// (3/4 of BOF) Buffer overflow flag. This bit is set when an overflow occurs during the offset calculation of the buffer 0. It is cleared by writing 1 to CB0OF.
        @"BOF[2]": u1,
        /// (4/4 of BOF) Buffer overflow flag. This bit is set when an overflow occurs during the offset calculation of the buffer 0. It is cleared by writing 1 to CB0OF.
        @"BOF[3]": u1,
        /// AHB master error flag. This bit is set when an AHB error happens during a transaction. It is cleared by writing 1 to CAMEF.
        AMEF: u1,
        padding: u27 = 0,
    }),
    /// GFXMMU flag clear register.
    /// offset: 0x08
    FCR: mmio.Mmio(packed struct(u32) {
        /// (1/4 of CBOF) Clear buffer overflow flag. Writing 1 clears the buffer 0 overflow flag in the GFXMMU_SR register.
        @"CBOF[0]": u1,
        /// (2/4 of CBOF) Clear buffer overflow flag. Writing 1 clears the buffer 0 overflow flag in the GFXMMU_SR register.
        @"CBOF[1]": u1,
        /// (3/4 of CBOF) Clear buffer overflow flag. Writing 1 clears the buffer 0 overflow flag in the GFXMMU_SR register.
        @"CBOF[2]": u1,
        /// (4/4 of CBOF) Clear buffer overflow flag. Writing 1 clears the buffer 0 overflow flag in the GFXMMU_SR register.
        @"CBOF[3]": u1,
        /// Clear AHB master error flag. Writing 1 clears the AHB master error flag in the GFXMMU_SR register.
        CAMEF: u1,
        padding: u27 = 0,
    }),
    /// GFXMMU cache control register.
    /// offset: 0x0c
    CCR: mmio.Mmio(packed struct(u32) {
        /// Force flush. When set, the cache entries are flushed. This bit is reset by hardware when the flushing is complete. Write 0 has no effect.
        FF: u1,
        /// Force invalidate. When set, the cache entries are invalidated. This bit is reset by hardware when the invalidation is complete. Write 0 has no effect.
        FI: u1,
        padding: u30 = 0,
    }),
    /// GFXMMU default value register.
    /// offset: 0x10
    DVR: mmio.Mmio(packed struct(u32) {
        /// Default value. This field indicates the default 32-bit value which is returned when a master accesses a virtual memory location not physically mapped.
        DV: u32,
    }),
    /// offset: 0x14
    reserved20: [12]u8,
    /// GFXMMU buffer 0 configuration register.
    /// offset: 0x20
    BCR: [4]mmio.Mmio(packed struct(u32) {
        reserved4: u4 = 0,
        /// Physical buffer offset. Offset of the physical buffer.
        PBO: u19,
        /// Physical buffer base address. Base address MSB of the physical buffer.
        PBBA: u9,
    }),
    /// offset: 0x30
    reserved48: [4048]u8,
    /// GFXMMU LUT entry 0 low.
    /// offset: 0x1000
    LUTL: mmio.Mmio(packed struct(u32) {
        /// Line enable.
        EN: u1,
        reserved8: u7 = 0,
        /// First Valid Block. Number of the first valid block of line number x.
        FVB: u8,
        /// Last Valid Block. Number of the last valid block of line number X.
        LVB: u8,
        padding: u8 = 0,
    }),
    /// GFXMMU LUT entry 0 high.
    /// offset: 0x1004
    LUTH: mmio.Mmio(packed struct(u32) {
        reserved4: u4 = 0,
        /// Line offset. Line offset of line number x (i.e. offset of block 0 of line x).
        LO: u18,
        padding: u10 = 0,
    }),
};
