const microzig = @import("microzig");
const mmio = microzig.mmio;

const types = @import("types.zig");

pub const MEM_MODE = enum(u2) {
    /// Main Flash memory mapped at address 0
    MAIN_FLASH = 0x0,
    /// System Flash memory mapped at address 0
    SYSTEM_FLASH = 0x1,
    /// Main Flash memory mapped at address 0 (alternate encoding)
    MAIN_FLASH_ALT = 0x2,
    /// Embedded SRAM mapped at address 0
    SRAM = 0x3,
};

/// System configuration controller
pub const SYSCFG = extern struct {
    /// configuration register 1
    /// offset: 0x00
    CFGR1: mmio.Mmio(packed struct(u32) {
        /// Memory mapping selection bits. This bitfield controlled by software selects the memory internally mapped at the address 0x0000_0000. Its reset value is determined by the boot mode configuration. Refer to Reference Manual section 2.5 for more details.
        MEM_MODE: MEM_MODE,
        reserved3: u1 = 0,
        /// PA11 pin remapping This bit is set and cleared by software. When set, it remaps the PA11 pin to operate as PA9 GPIO port, instead as PA11 GPIO port.
        PA11_RMP: u1,
        /// PA12 pin remapping This bit is set and cleared by software. When set, it remaps the PA12 pin to operate as PA10 GPIO port, instead as PA12 GPIO port.
        PA12_RMP: u1,
        /// IR output polarity selection
        IR_POL: u1,
        /// IR Modulation Envelope signal selection.
        IR_MOD: u2,
        /// I/O analog switch voltage booster enable
        BOOSTEN: u1,
        /// Strobe signal bit for UCPD1
        UCPD1_STROBE: u1,
        /// Strobe signal bit for UCPD2
        UCPD2_STROBE: u1,
        reserved16: u5 = 0,
        /// Fast Mode Plus (FM+) driving capability activation bits
        I2C_PBx_FMP: u4,
        /// FM+ driving capability activation for I2C1
        I2C1_FMP: u1,
        /// FM+ driving capability activation for I2C2
        I2C2_FMP: u1,
        /// Fast Mode Plus (FM+) driving capability activation bits
        I2C_PAx_FMP: u2,
        padding: u8 = 0,
    }),
    /// offset: 0x04
    reserved4: [20]u8,
    /// configuration register 1
    /// offset: 0x18
    CFGR2: mmio.Mmio(packed struct(u32) {
        /// Cortex-M0+ LOCKUP bit enable bit
        LOCKUP_LOCK: u1,
        /// SRAM parity lock bit
        SRAM_PARITY_LOCK: u1,
        /// PVD lock enable bit
        PVD_LOCK: u1,
        /// ECC error lock bit
        ECC_LOCK: u1,
        reserved8: u4 = 0,
        /// SRAM parity error flag
        SRAM_PEF: u1,
        reserved16: u7 = 0,
        /// PA1_CDEN
        PA1_CDEN: u1,
        /// PA3_CDEN
        PA3_CDEN: u1,
        /// PA5_CDEN
        PA5_CDEN: u1,
        /// PA6_CDEN
        PA6_CDEN: u1,
        /// PA13_CDEN
        PA13_CDEN: u1,
        /// PB0_CDEN
        PB0_CDEN: u1,
        /// PB1_CDEN
        PB1_CDEN: u1,
        /// PB2_CDEN
        PB2_CDEN: u1,
        padding: u8 = 0,
    }),
    /// offset: 0x1c
    reserved28: [20]u8,
    /// VREFBUF control and status register
    /// offset: 0x30
    VREFBUF_CSR: mmio.Mmio(packed struct(u32) {
        /// Voltage reference buffer mode enable This bit is used to enable the voltage reference buffer mode.
        ENVR: u1,
        /// High impedance mode This bit controls the analog switch to connect or not the VREF+ pin. Refer to Table196: VREF buffer modes for the mode descriptions depending on ENVR bit configuration.
        HIZ: u1,
        reserved3: u1 = 0,
        /// Voltage reference buffer ready
        VRR: u1,
        /// Voltage reference scale These bits select the value generated by the voltage reference buffer. Other: Reserved
        VRS: u3,
        padding: u25 = 0,
    }),
    /// VREFBUF calibration control register
    /// offset: 0x34
    VREFBUF_CCR: mmio.Mmio(packed struct(u32) {
        /// Trimming code These bits are automatically initialized after reset with the trimming value stored in the Flash memory during the production test. Writing into these bits allows to tune the internal reference buffer voltage.
        TRIM: u6,
        padding: u26 = 0,
    }),
    /// offset: 0x38
    reserved56: [72]u8,
    /// interrupt line 0 status register
    /// offset: 0x80
    ITLINE0: mmio.Mmio(packed struct(u32) {
        /// Window watchdog interrupt pending flag
        WWDG: u1,
        padding: u31 = 0,
    }),
    /// interrupt line 1 status register
    /// offset: 0x84
    ITLINE1: mmio.Mmio(packed struct(u32) {
        /// PVD supply monitoring interrupt request pending (EXTI line 16).
        PVDOUT: u1,
        padding: u31 = 0,
    }),
    /// interrupt line 2 status register
    /// offset: 0x88
    ITLINE2: mmio.Mmio(packed struct(u32) {
        /// TAMP
        TAMP: u1,
        /// RTC
        RTC: u1,
        padding: u30 = 0,
    }),
    /// interrupt line 3 status register
    /// offset: 0x8c
    ITLINE3: mmio.Mmio(packed struct(u32) {
        /// FLASH_ITF
        FLASH_ITF: u1,
        /// FLASH_ECC
        FLASH_ECC: u1,
        padding: u30 = 0,
    }),
    /// interrupt line 4 status register
    /// offset: 0x90
    ITLINE4: mmio.Mmio(packed struct(u32) {
        /// RCC
        RCC: u1,
        padding: u31 = 0,
    }),
    /// interrupt line 5 status register
    /// offset: 0x94
    ITLINE5: mmio.Mmio(packed struct(u32) {
        /// EXTI0
        EXTI0: u1,
        /// EXTI1
        EXTI1: u1,
        padding: u30 = 0,
    }),
    /// interrupt line 6 status register
    /// offset: 0x98
    ITLINE6: mmio.Mmio(packed struct(u32) {
        /// EXTI2
        EXTI2: u1,
        /// EXTI3
        EXTI3: u1,
        padding: u30 = 0,
    }),
    /// interrupt line 7 status register
    /// offset: 0x9c
    ITLINE7: mmio.Mmio(packed struct(u32) {
        /// EXTI4
        EXTI4: u1,
        /// EXTI5
        EXTI5: u1,
        /// EXTI6
        EXTI6: u1,
        /// EXTI7
        EXTI7: u1,
        /// EXTI8
        EXTI8: u1,
        /// EXTI9
        EXTI9: u1,
        /// EXTI10
        EXTI10: u1,
        /// EXTI11
        EXTI11: u1,
        /// EXTI12
        EXTI12: u1,
        /// EXTI13
        EXTI13: u1,
        /// EXTI14
        EXTI14: u1,
        /// EXTI15
        EXTI15: u1,
        padding: u20 = 0,
    }),
    /// interrupt line 8 status register
    /// offset: 0xa0
    ITLINE8: mmio.Mmio(packed struct(u32) {
        /// UCPD1
        UCPD1: u1,
        /// UCPD2
        UCPD2: u1,
        /// USB
        USB: u1,
        padding: u29 = 0,
    }),
    /// interrupt line 9 status register
    /// offset: 0xa4
    ITLINE9: mmio.Mmio(packed struct(u32) {
        /// DMA1_CH1
        DMA1_CH1: u1,
        padding: u31 = 0,
    }),
    /// interrupt line 10 status register
    /// offset: 0xa8
    ITLINE10: mmio.Mmio(packed struct(u32) {
        /// DMA1_CH1
        DMA1_CH2: u1,
        /// DMA1_CH3
        DMA1_CH3: u1,
        padding: u30 = 0,
    }),
    /// interrupt line 11 status register
    /// offset: 0xac
    ITLINE11: mmio.Mmio(packed struct(u32) {
        /// DMAMUX
        DMAMUX: u1,
        /// DMA1_CH4
        DMA1_CH4: u1,
        /// DMA1_CH5
        DMA1_CH5: u1,
        /// DMA1_CH6
        DMA1_CH6: u1,
        /// DMA1_CH7
        DMA1_CH7: u1,
        padding: u27 = 0,
    }),
    /// interrupt line 12 status register
    /// offset: 0xb0
    ITLINE12: mmio.Mmio(packed struct(u32) {
        /// ADC
        ADC: u1,
        /// COMP1
        COMP1: u1,
        /// COMP2
        COMP2: u1,
        padding: u29 = 0,
    }),
    /// interrupt line 13 status register
    /// offset: 0xb4
    ITLINE13: mmio.Mmio(packed struct(u32) {
        /// TIM1_CCU
        TIM1_CCU: u1,
        /// TIM1_TRG
        TIM1_TRG: u1,
        /// TIM1_UPD
        TIM1_UPD: u1,
        /// TIM1_BRK
        TIM1_BRK: u1,
        padding: u28 = 0,
    }),
    /// interrupt line 14 status register
    /// offset: 0xb8
    ITLINE14: mmio.Mmio(packed struct(u32) {
        /// TIM1_CC
        TIM1_CC: u1,
        padding: u31 = 0,
    }),
    /// interrupt line 15 status register
    /// offset: 0xbc
    ITLINE15: mmio.Mmio(packed struct(u32) {
        /// TIM2
        TIM2: u1,
        padding: u31 = 0,
    }),
    /// interrupt line 16 status register
    /// offset: 0xc0
    ITLINE16: mmio.Mmio(packed struct(u32) {
        /// TIM3
        TIM3: u1,
        padding: u31 = 0,
    }),
    /// interrupt line 17 status register
    /// offset: 0xc4
    ITLINE17: mmio.Mmio(packed struct(u32) {
        /// TIM6
        TIM6: u1,
        /// DAC
        DAC: u1,
        /// LPTIM1
        LPTIM1: u1,
        padding: u29 = 0,
    }),
    /// interrupt line 18 status register
    /// offset: 0xc8
    ITLINE18: mmio.Mmio(packed struct(u32) {
        /// TIM7
        TIM7: u1,
        /// LPTIM2
        LPTIM2: u1,
        padding: u30 = 0,
    }),
    /// interrupt line 19 status register
    /// offset: 0xcc
    ITLINE19: mmio.Mmio(packed struct(u32) {
        /// TIM14
        TIM14: u1,
        padding: u31 = 0,
    }),
    /// interrupt line 20 status register
    /// offset: 0xd0
    ITLINE20: mmio.Mmio(packed struct(u32) {
        /// TIM15
        TIM15: u1,
        padding: u31 = 0,
    }),
    /// interrupt line 21 status register
    /// offset: 0xd4
    ITLINE21: mmio.Mmio(packed struct(u32) {
        /// TIM16
        TIM16: u1,
        padding: u31 = 0,
    }),
    /// interrupt line 22 status register
    /// offset: 0xd8
    ITLINE22: mmio.Mmio(packed struct(u32) {
        /// TIM17
        TIM17: u1,
        padding: u31 = 0,
    }),
    /// interrupt line 23 status register
    /// offset: 0xdc
    ITLINE23: mmio.Mmio(packed struct(u32) {
        /// I2C1
        I2C1: u1,
        padding: u31 = 0,
    }),
    /// interrupt line 24 status register
    /// offset: 0xe0
    ITLINE24: mmio.Mmio(packed struct(u32) {
        /// I2C2
        I2C2: u1,
        padding: u31 = 0,
    }),
    /// interrupt line 25 status register
    /// offset: 0xe4
    ITLINE25: mmio.Mmio(packed struct(u32) {
        /// SPI1
        SPI1: u1,
        padding: u31 = 0,
    }),
    /// interrupt line 26 status register
    /// offset: 0xe8
    ITLINE26: mmio.Mmio(packed struct(u32) {
        /// SPI2
        SPI2: u1,
        padding: u31 = 0,
    }),
    /// interrupt line 27 status register
    /// offset: 0xec
    ITLINE27: mmio.Mmio(packed struct(u32) {
        /// USART1
        USART1: u1,
        padding: u31 = 0,
    }),
    /// interrupt line 28 status register
    /// offset: 0xf0
    ITLINE28: mmio.Mmio(packed struct(u32) {
        /// USART2
        USART2: u1,
        padding: u31 = 0,
    }),
    /// interrupt line 29 status register
    /// offset: 0xf4
    ITLINE29: mmio.Mmio(packed struct(u32) {
        USART3: u1,
        USART4: u1,
        reserved3: u1 = 0,
        USART5: u1,
        USART6: u1,
        padding: u27 = 0,
    }),
    /// interrupt line 30 status register
    /// offset: 0xf8
    ITLINE30: mmio.Mmio(packed struct(u32) {
        /// CEC
        CEC: u1,
        padding: u31 = 0,
    }),
    /// interrupt line 31 status register
    /// offset: 0xfc
    ITLINE31: mmio.Mmio(packed struct(u32) {
        /// RNG
        RNG: u1,
        /// AES
        AES: u1,
        padding: u30 = 0,
    }),
};
